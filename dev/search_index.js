var documenterSearchIndex = {"docs":
[{"location":"multithreading.html#Partitions-threads","page":"Multithreading","title":"Partitions threads","text":"","category":"section"},{"location":"multithreading.html","page":"Multithreading","title":"Multithreading","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/WavKinS_partitions_threads.jl\"]","category":"page"},{"location":"multithreading.html#WavKinS.get_partition","page":"Multithreading","title":"WavKinS.get_partition","text":"get_partition(Mx, My, nthreads, nthx=0, nthy=0)\n\nReturn nthreads vectors of indices partitioning Mx × My grid points for multithreading. \n\nnthx: number of cuts in the x direction\nnthy: number of cuts in the y direction\n\nWe must have nthx × nthy == nthreads.\n\n\n\n\n\n","category":"function"},{"location":"multithreading.html#WavKinS.get_partition-Tuple{Any, Any}","page":"Multithreading","title":"WavKinS.get_partition","text":"get_partition(M, nthreads)\n\nReturn nthreads vectors of indices partitioning M grid points for multithreading\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#Numerical-methods","page":"Numerical methods","title":"Numerical methods","text":"","category":"section"},{"location":"numerical-methods.html#Grid","page":"Numerical methods","title":"Grid","text":"","category":"section"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Here are the methods used to create grids and compute related quantities.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Modules = [WavKinS]\nOrder   = [:type,:function]\nPages   = [\"src/grid/WavKinS_grid.jl\"]","category":"page"},{"location":"numerical-methods.html#WavKinS.LogRange-Tuple{Any, Any, Any}","page":"Numerical methods","title":"WavKinS.LogRange","text":"LogRange(kmin,kmax,M)\n\nCreate M logarithmic grid points between kmin and kmax.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.area_ratio-NTuple{4, Any}","page":"Numerical methods","title":"WavKinS.area_ratio","text":"area_ratio(yi,yu,yl,yr)\n\nArea of a box (x,y) ∈ [xl,xr] × [yi,yu] that is below the line passing by (xl,yl) and (xr,yr), divided by the total area of the box.\n\nNote: does not depend on xl and xr.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.area_ratio_grid-Tuple{Any, Any, Any}","page":"Numerical methods","title":"WavKinS.area_ratio_grid","text":"area_ratio_grid(x, y, f)\n\nFor each cell of the grid x × y, return the area under f divided by the total area of the box. \n\nNote: convolution allows to integrate over y < f.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.area_ratio_logbins-NTuple{4, Any}","page":"Numerical methods","title":"WavKinS.area_ratio_logbins","text":"area_ratio_logbins(kkh, kkz, logλz, f)\n\nSame as area_ratio_grid but for logarithmic grids. \n\nkkh: horizontal wave vectors grid points\nkkz: vertical wave vectors grid points\nlogλz: log(λz) where λz is the logarithmic increment of the vertical wave vectors grid\nf: values of f vs kkh\n\nNote: convolution allows to integrate over kkz < f.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.change_mesh!-Tuple{Any, Any}","page":"Numerical methods","title":"WavKinS.change_mesh!","text":"change_mesh!(Nknew,Nkold;interp_scheeme=BS_interp)\n\nFill Nknew wave action spectrum from interpolation interp_scheeme of Nkold.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.meshgrid-Tuple{Any, Any}","page":"Numerical methods","title":"WavKinS.meshgrid","text":"meshgrid(x, y)\n\nCreate 2D grids from the 1D vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#Interpolation","page":"Numerical methods","title":"Interpolation","text":"","category":"section"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"In the following figure, we represent a mesh of the wave vector grid for 1D systems (left) and 2D systems (right) problem.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"(Image: )","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"For 1D systems, the i^rm th mesh is mathcalC_i equiv k_i-1 k_i except for the first mesh which correspond to the segment mathcalC_1 = 0k_1. We extend this definition to 2D systems as mathcalC_i_hi_z equiv k_hi_h-1 k_hi_h times k_zi_z-1 k_zi_z.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Inside each mesh, we use a given mathematical expression for interpolating the waveaction at k (or (k_hk_z)) knowing the value of the waveaction n_i-1 = n(k_i-1) and n_i = n(k_i) (or n_1 = n(k_hi_h-1 k_zi_z-1), n_2 = n(k_hi_h k_zi_z-1), n_3 = n(k_hi_h k_zi_z) and n_4 = n(k_hi_h-1 k_zi_z)). This mathematical expression depends on the interpolation method.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"example: Example\nFor using the linear interpolation method lin_interp with the Acoustic2D solver, you define the simulation strucure Run as Run = Acoustic2D(Nk; interp_scheeme=WavKinS.lin_interp).","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"For each interpolation method, we store interpolation coefficients in stuctures that are defined in src/interpolation/WavKinS_interpolation_structs.jl. We compute these coefficients using the update_coeff_interp! method (one definition per interpolation method). Once the coefficients have been updated, you can compute the value of the waveaction at point k (or (k_hk_z)) using the method val_nk. ","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"note: Note\nval_nk is overloaded to allow changing the interpolation scheme without changing anything in the solvers. For more informations about the interpolations methods, please refer to update_coeff_interp! documentation.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/interpolation/WavKinS_interpolation_structs.jl\", \"src/interpolation/WavKinS_interpolation.jl\"]","category":"page"},{"location":"numerical-methods.html#WavKinS.BS_interp-Tuple{AbstractVector}","page":"Numerical methods","title":"WavKinS.BS_interp","text":"BS_interp(kk::AbstractVector)\n\nAllocate nodes for BSplines interpolation. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.bilin_interp_khkz-Tuple{AbstractVector, AbstractVector}","page":"Numerical methods","title":"WavKinS.bilin_interp_khkz","text":"bilin_interp_khkz(kkh::AbstractVector, kkz::AbstractVector)\n\nAllocate coefficients for bilinear interpolation and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.bilinlog_interp_khkz-Tuple{AbstractVector, AbstractVector}","page":"Numerical methods","title":"WavKinS.bilinlog_interp_khkz","text":"bilinlog_interp_khkz(kkh::AbstractVector, kkz::AbstractVector)\n\nAllocate coefficients for bilinear interpolation in log scale and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cpow_interp_khkz-Tuple{AbstractVector, AbstractVector}","page":"Numerical methods","title":"WavKinS.cpow_interp_khkz","text":"cpow_interp_khkz(kkh::AbstractVector, kkz::AbstractVector)\n\nAllocate coefficients for cpow interpolation and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.exp_interp_khkz-Tuple{AbstractVector, AbstractVector}","page":"Numerical methods","title":"WavKinS.exp_interp_khkz","text":"exp_interp_khkz(kkh::AbstractVector, kkz::AbstractVector)\n\nAllocate coefficients for exponential interpolation and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.lin_interp-Tuple{AbstractVector}","page":"Numerical methods","title":"WavKinS.lin_interp","text":"lin_interp(kk::AbstractVector)\n\nAllocate coefficients for linear interpolation and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.linlog_interp-Tuple{AbstractVector}","page":"Numerical methods","title":"WavKinS.linlog_interp","text":"linlog_interp(kk::AbstractVector)\n\nAllocate coefficients for linear interpolation in log scale (power law) and define interpolation method. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.powGauss_interp-Tuple{AbstractVector}","page":"Numerical methods","title":"WavKinS.powGauss_interp","text":"powGauss_interp(kk::AbstractVector)\n\nAllocate coefficients for power-law Gaussian interpolation. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.powexp_interp-Tuple{AbstractVector}","page":"Numerical methods","title":"WavKinS.powexp_interp","text":"powexp_interp(kk::AbstractVector)\n\nAllocate coefficients for power-law exponential interpolation. See val_nk.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.bilin_interp_vs-NTuple{10, Any}","page":"Numerical methods","title":"WavKinS.bilin_interp_vs","text":"bilin_interp_vs(kh,kz,khinf,khsup,kzinf,kzsup,n1,n2,n3,n4)\n\nReturn the bilinear interpolation of n_bf k at point (kh,kz) computed using the points (khinf,kzinf,n1), (khsup,kzinf,n2), (khsup,kzsup,n3) and (khinf,kzsup,n4).\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.lin_interp_vs-NTuple{5, Any}","page":"Numerical methods","title":"WavKinS.lin_interp_vs","text":"lin_interp_vs(k,k1,k2,n1,n2)\n\nReturn the linear interpolation of n_k at point k computed using the points (k1,n1) and (k2,n2)\n\nn_k = n_1 frack_2-kk_2-k_1 + n_2 frack-k_1k_2-k_1 \n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.BS_interp, wave_spectrum}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(interp::BS_interp,Nk::wave_spectrum)\n\nCompute the coefficients for B-spline interpolation. The method is given by the BSplineKit package.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.bilin_interp_khkz, wave_spectrum_khkz}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::bilin_interp_khkz, Nk::wave_spectrum_khkz)\n\nCompute the coefficients C_0, alpha_h, alpha_z and beta for bilinear interpolation such that n_bf k = C_0 - alpha_h k_h - alpha_z k_z - beta k_h k_z.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.bilinlog_interp_khkz, wave_spectrum_khkz}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::bilinlog_interp_khkz, Nk::wave_spectrum_khkz)\n\nCompute the coefficients C_0, alpha_h, alpha_z and beta for bilinear interpolation in logarithmic scale (power law) such that n_bf k = e^C_0 - alpha_h log k_h - alpha_z log k_z - beta log k_h log k_z.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.cpow_interp_khkz, wave_spectrum_khkz}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::cpow_interp_khkz, Nk::wave_spectrum_khkz)\n\nCompute the coefficients C_0, alpha_h, alpha_z and beta for bilinear interpolation such that n_bf k = beta + C_0  k_h^-alpha_h k_z^-alpha_z k_z.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.exp_interp_khkz, wave_spectrum_khkz}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::exp_interp_khkz, Nk::wave_spectrum_khkz)\n\nCompute the coefficients C_0, alpha_h, alpha_z and beta for exponential interpolation such that n_bf k = e^C_0 - alpha_h k_h - alpha_z k_z - beta k_h k_z.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.lin_interp, wave_spectrum}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::lin_interp,Nk::wave_spectrum)\n\nCompute the coefficients alpha and beta for linear interpolation such that n_bf k = alpha + beta k.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.linlog_interp, wave_spectrum}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::linlog_interp,Nk::wave_spectrum)\n\nCompute the coefficients alpha and C_0 for linear interpolation in logarithmic scale (power law) such that n_bf k = C_0 k^-alpha = C_0 e^- alpha log k.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.powGauss_interp, wave_spectrum}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::powexp_interp,Nk::wave_spectrum)\n\nCompute the coefficients C_0, alpha and beta for power law Gaussian interpolation such that n_bf k = C_0 k^-alpha e^-beta k^2.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.update_coeff_interp!-Tuple{WavKinS.powexp_interp, wave_spectrum}","page":"Numerical methods","title":"WavKinS.update_coeff_interp!","text":"update_coeff_interp!(::powexp_interp,Nk::wave_spectrum)\n\nCompute the coefficients C_0, alpha and beta for power law exponential interpolation such that n_bf k = C_0 k^-alpha e^-beta k.\n\nNk: Structure containing the wave action wave_spectrum\ninterp: structure where the coefficients are stored\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.bilin_interp_khkz, wave_spectrum_khkz, Any, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::bilin_interp_khkz, Nk::wave_spectrum_khkz, kh, kz)\n\nReturn the value of Nk.nk interpolated at (kh, kz) (with bilin_interp_khkz). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.bilinlog_interp_khkz, wave_spectrum_khkz, Any, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::bilinlog_interp_khkz, Nk::wave_spectrum_khkz, kh, kz)\n\nReturn the value of Nk.nk interpolated at (kh, kz) (with bilinlog_interp_khkz). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.cpow_interp_khkz, wave_spectrum_khkz, Any, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::cpow_interp_khkz, Nk::wave_spectrum_khkz, kh, kz)\n\nReturn the value of Nk.nk interpolated at (kh, kz) (with cpow_interp_khkz). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.exp_interp_khkz, wave_spectrum_khkz, Any, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::exp_interp_khkz, Nk::wave_spectrum_khkz, kh, kz)\n\nReturn the value of Nk.nk interpolated at (kh, kz) (with exp_interp_khkz). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.lin_interp, wave_spectrum, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::lin_interp,Nk::waveaction,k)\n\nReturn the value of Nk.nk interpolated at k (with lin_interp). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.linlog_interp, wave_spectrum, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::linlog_interp,Nk::waveaction,k)\n\nReturn the value of Nk.nk interpolated at k (with linlog_interp). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.powGauss_interp, wave_spectrum, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(interp::powGauss_interp, Nk::wave_spectrum, k)\n\nReturn the value of Nk.nk interpolated at k (with powGauss_interp). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.val_nk-Tuple{WavKinS.powexp_interp, wave_spectrum, Any}","page":"Numerical methods","title":"WavKinS.val_nk","text":"val_nk(::powexp_interp,Nk::waveaction,k)\n\nReturn the value of Nk.nk interpolated at k (with powexp_interp). Coefficients should be updated.\n\nSee also update_coeff_interp!\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#Integration","page":"Numerical methods","title":"Integration","text":"","category":"section"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Like for \"interpolation\", you can choose an integration method (independently). Integration are performed by summing over meshes using the integrate method (one definition per interpolation method).  ","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"example: Example\nFor using the integration method integrate_with_log_bins to integrate Nk.nk over meshes imin to imax, you use integrate(integrate_with_log_bins, Nk, imin, imax). Note that integrate(integrate_with_log_bins, Nk, i, i) return the integral over mesh i only (i.e. between k_i-1 and k_i).","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"note: Note\nintegrate is overloaded to allow changing the integration scheme without changing anything in the solvers. For more informations about the integrations methods, please refer to integrate documentation.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/integration/WavKinS_integration_structs.jl\", \"src/integration/WavKinS_integration.jl\"]","category":"page"},{"location":"numerical-methods.html#WavKinS.integrate_with_cpow_khkz","page":"Numerical methods","title":"WavKinS.integrate_with_cpow_khkz","text":"integrate_with_cpow_khkz()\n\nSelect the use of the cpow integration with log bins khkz method. See integrate.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.integrate_with_log_bins_khkz","page":"Numerical methods","title":"WavKinS.integrate_with_log_bins_khkz","text":"integrate_with_log_bins_khkz()\n\nSelect the use of the trapezoidal integration with log bins khkz method. See integrate.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.clean_waveaction!-Tuple{Union{wave_spectrum, wave_spectrum_khkz}}","page":"Numerical methods","title":"WavKinS.clean_waveaction!","text":"clean_waveaction!(Nk::waveaction)\n\nSet the minimum of the waveaction spectrum Nk.nk to min_nk. By default min_nk=0 so it removes negative values.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cumintegrate!-Tuple{AbstractVector, Int64, Float64, Float64, Vector{Float64}, Vector{Float64}}","page":"Numerical methods","title":"WavKinS.cumintegrate!","text":"cumintegrate!(CumInt::AbstractVector, M::Int, λ::Float64, logλ::Float64, kk::Vector{Float64}, F::Vector{Float64})\n\nCompute cumulative integral of F using log bins and trapezoidal rule. The result is stored in CumInt.\n\nM: number of grid points\nλ: logarithmic increment of the grid\nlogλ: log(λ)\nkk: grid \n\nSee also integrate_with_log_bins.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cumintegrate!-Tuple{AbstractVector, wave_spectrum}","page":"Numerical methods","title":"WavKinS.cumintegrate!","text":"cumintegrate!(CumInt::AbstractVector, Sk::wave_spectrum)\n\nCompute cumulative integral of Sk.Nk using log bins and trapezoidal rule. The result is stored in CumInt.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cumintegraterev!-Tuple{AbstractVector, Int64, Float64, Float64, Vector{Float64}, Vector{Float64}}","page":"Numerical methods","title":"WavKinS.cumintegraterev!","text":"cumintegraterev!(CumInt::AbstractVector, M::Int, λ::Float64, logλ::Float64, kk::Vector{Float64}, F::Vector{Float64})\n\nCompute cumulative integral using log bins in reverse order.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cumintegraterev!-Tuple{AbstractVector, wave_spectrum}","page":"Numerical methods","title":"WavKinS.cumintegraterev!","text":"cumintegraterev!(CumInt::AbstractVector, Sk::wave_spectrum)\n\nCompute cumulative integral using log bins in reverse order.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.integrate","page":"Numerical methods","title":"WavKinS.integrate","text":"integrate(Nk::wave_spectrum, imin::Int=1, imax::Int=-1)\n\nReturn the integral of Nk.nk using (simple) trapezoidal rule from index imin to imax.  By default, it integrates over the whole domain.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate-2","page":"Numerical methods","title":"WavKinS.integrate","text":"integrate_with_grid(Sk::field_grid_1D, imin::Int=1, imax::Int=-1)\n\nReturn the integral of Sk.F using (simple) trapezoidal rule on grid Sk.kk between index imin and imax. \n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate-3","page":"Numerical methods","title":"WavKinS.integrate","text":"integrate(integ::integrate_with_cpow_khkz, Nk::wave_spectrum_khkz, ihmin::Int=1, ihmax::Int=-1, izmin::Int=1, izmax::Int=-1)\n\nReturn the integral of Nk.nk assuming n_bf k = beta + C_0  k_h^-alpha_h k_z^-alpha_z k_z in each mesh from index ihmin to ihmax and izmin to izmax.  By default, it integrates over the whole domain.\n\nSee also cpow_interp_khkz.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate-4","page":"Numerical methods","title":"WavKinS.integrate","text":"integrate(integ::integrate_with_log_bins_khkz, Nk::wave_spectrum_khkz, ihmin::Int=1, ihmax::Int=-1, izmin::Int=1, izmax::Int=-1)\n\nReturn the integral of Nk.nk using log bins and trapezoidal rule from index ihmin to ihmax and izmin to izmax.  By default, it integrates over the whole domain.\n\nNamely I = intlimits_k_hrm min^k_hrm max intlimits_k_zrm min^k_zrm max  F(k_hk_z)  mathrmdk_h mathrmdk_z = intlimits_i_hrm min^i_hrm max intlimits_i_zrm min^i_zrm max  F(k_h=lambda_h^i_h k_z=lambda_z^i_z)  lambda_h^i_h lambda_z^i_z ln lambda_h ln lambda_z  mathrmd i_h mathrmd i_z. \n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate_quad_with_log_bins","page":"Numerical methods","title":"WavKinS.integrate_quad_with_log_bins","text":"integrate_quad_with_log_bins(Nk::wave_spectrum, imin::Int=1, imax::Int=-1)\n\nReturn the integral of Nk.nk using log bins and Simpson rule from index imin to imax.  By default, it integrates over the whole domain.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate_with_grid","page":"Numerical methods","title":"WavKinS.integrate_with_grid","text":"integrate_with_grid(x, F, imin::Int=1, imax::Int=-1)\n\nReturn the integral of F using (simple) trapezoidal rule on grid x between index imin and imax. \n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate_with_log_bins","page":"Numerical methods","title":"WavKinS.integrate_with_log_bins","text":"integrate_with_log_bins(Nk::wave_spectrum, imin::Int=1, imax::Int=-1)\n\nReturn the integral of Nk.nk using log bins and trapezoidal rule from index imin to imax. By default, it integrates over the whole domain.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate_with_log_bins-2","page":"Numerical methods","title":"WavKinS.integrate_with_log_bins","text":"integrate_with_log_bins(M::Int, λ::Float64, logλ::Float64, kk::Vector{Float64}, F::Vector{Float64}, imin::Int=1, imax::Int=-1)\n\nReturn the integral of F using log bins and trapezoidal rule from index imin to imax.\n\nM: number of grid points\nλ: logarithmic increment of the grid\nlogλ: log(λ)\nkk: grid \n\nBy default, it integrates over the whole domain. Namely I = intlimits_k_rm min^k_rm max  F(k)  mathrmdk = intlimits_i_rm min^i_rm max  F(k=lambda^i ) lambda^i ln lambda  mathrmd i. It uses trapezoidal rule.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.integrate_with_log_bins_segment-NTuple{4, Any}","page":"Numerical methods","title":"WavKinS.integrate_with_log_bins_segment","text":"integrate_with_log_bins_segment(Fa, Fb, ka, kb)\n\nReturn the integral of F using trapezoidal log bins from ka to kb. \n\nFa: value of F at ka\nFb: value of F at kb\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#Time-stepping","page":"Numerical methods","title":"Time-stepping","text":"","category":"section"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"You can choose between several time stepping methods. Time advancement is done with the advance! method (one definition per time-stepping method).  ","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"example: Example\nFor using the time stepping method ETD4_step to advance time of dt, you use advance!(ETD4_step, Run, dt). ","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"note: Note\nadvance! is overloaded to allow changing the time stepping scheme without changing anything in the solvers. For more informations about the integrations methods, please refer to advance! documentation.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/time_stepping/WavKinS_time_stepping_structs.jl\", \"src/time_stepping/WavKinS_time_stepping.jl\"]","category":"page"},{"location":"numerical-methods.html#WavKinS.AB2_RK2_step","page":"Numerical methods","title":"WavKinS.AB2_RK2_step","text":"AB2_RK2_step()\n\nSet the use of split Second-order-Exponential-Adams-Bashforth and Runge-Kutta 2. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.AB2_RK2arrays","page":"Numerical methods","title":"WavKinS.AB2_RK2arrays","text":"AB2_RK2arrays\n\nStructure for split Second-order-Exponential-Adams-Bashforth and Runge-Kutta 2\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.AB_Euler_step","page":"Numerical methods","title":"WavKinS.AB_Euler_step","text":"AB_Euler_step()\n\nSet the use of split Exponential-Adams-Bashforth and Euler. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.ETD2_step","page":"Numerical methods","title":"WavKinS.ETD2_step","text":"ETD2_step()\n\nSet the use of ETD2. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.ETD2arrays","page":"Numerical methods","title":"WavKinS.ETD2arrays","text":"ETD2arrays\n\nStructure for ETD2 \n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.ETD4_step","page":"Numerical methods","title":"WavKinS.ETD4_step","text":"ETD4_step()\n\nSet the use of ETD4. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.ETD4arrays","page":"Numerical methods","title":"WavKinS.ETD4arrays","text":"ETD4arrays\n\nStructure for ETD4 \n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.Euler_step","page":"Numerical methods","title":"WavKinS.Euler_step","text":"Euler_step()\n\nSet the use of a simple Euler. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.RK2_step","page":"Numerical methods","title":"WavKinS.RK2_step","text":"RK2_step()\n\nSet the use of a Runge-Kutta 2. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.RK2arrays","page":"Numerical methods","title":"WavKinS.RK2arrays","text":"RK2arrays\n\nStructure for standard Runge-Kutta 2\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.RK4_step","page":"Numerical methods","title":"WavKinS.RK4_step","text":"RK4_step()\n\nSet the use of 4th-order Runge-Kutta 4, no forcing nor dissipation. See advance!.\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.RK4arrays","page":"Numerical methods","title":"WavKinS.RK4arrays","text":"RK4arrays\n\nStructure for standard Runge-Kutta 4, no forcing nor dissipation\n\n\n\n\n\n","category":"type"},{"location":"numerical-methods.html#WavKinS.adaptative_time_step","page":"Numerical methods","title":"WavKinS.adaptative_time_step","text":"adaptative_time_step(Run, dtmin, dtmax, dt, cmin=0.05, cmax=0.5)\n\nReturn the adaptated time step based on the wave action spectrum.  \n\nRun: run structure.   \ndtmin: minimal time step.   \ndtmax: maximal time step.   \ndt: current time step.   \ncmin: lower threshold for the ratio of the nonlinear time step and current time step.    \ncmax: upper threshold for the ratio of the nonlinear time step and current time step.  \n\nSee also get_T_nonlinear.\n\nwarning: Warning\nThis adaptative time step may not work for wave action that decrease very quickly.\n\n\n\n\n\n","category":"function"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{Euler_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::Euler_step, Run, dt)\n\nMake one time step with Euler_step.\n\nRun: run structure\ndt: time step\n\nThe time advancement is simply n_bf k(t+mathrmdt) = left St_rm k + f_bf k - d_bf k n_bf k right  mathrmdt.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{RK2_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::RK2_step, Run, dt)\n\nMake one time step with RK2_step.\n\nRun: run structure\ndt: time step\n\nThe time advancement is done with Runge-Kutta 2 method.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{RK4_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::RK4_step, Run, dt)\n\nMake one time step with RK4_step.\n\nRun: run structure\ndt: time step\n\nThe time advancement is done with Runge-Kutta 4 method.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{WavKinS.AB2_RK2_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::AB2_RK2_step, Run, dt)\n\nMake one time step with AB2_RK2_step.\n\nRun: run structure\ndt: time step\n\nThe collision integral is decomposed as St_bf k = - gamma_bf k n_bf k + eta_bf k. Time advancement is done with a splitting method, treating the term -(gamma_bf k + d_bf k) n_bf k implicitly and the term eta_bf k + f_bf k explicitly with Runge-Kutta 2 method.\n\nNote: The Run structure must have the coefficients gamma_bf k and eta_bf k that must be computed in St_k!. This scheeme is not implemented for all physical systems.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{WavKinS.AB_Euler_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::AB_Euler_step, Run, dt)\n\nMake one time step with AB_Euler_step.\n\nRun: run structure\ndt: time step\n\nThe collision integral is decomposed as St_bf k = - gamma_bf k n_bf k + eta_bf k. Time advancement is done with a splitting method, treating the term -(gamma_bf k + d_bf k) n_bf k implicitly and the term eta_bf k + f_bf k explicitly with Euler method.\n\nNote: The Run structure must have the coefficients gamma_bf k and eta_bf k that must be computed in St_k!. This scheeme is not implemented for all physical systems.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{WavKinS.ETD2_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::ETD2_step, Run, dt)\n\nMake one time step with ETD2_step.\n\nRun: run structure\ndt: time step\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.advance!-Tuple{WavKinS.ETD4_step, Any, Any}","page":"Numerical methods","title":"WavKinS.advance!","text":"advance!(::ETD4_step, Run, dt)\n\nMake one time step with ETD4_step.\n\nRun: run structure\ndt: time step\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.get_T_nonlinear-Tuple{Any}","page":"Numerical methods","title":"WavKinS.get_T_nonlinear","text":"get_T_nonlinear(Run)\n\nNon linear time based on the wave action spectrum\n\ntau_rm nl = frac1maxlimits_bf k left fracSt_bf kn_bf k right \n\nWe use only the energetic modes with n_bf k  10^-50.\n\nNote: We use tau_rm nl to fix the adaptative time step (see adaptative_time_step). \n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.init_temporal_scheeme!-Tuple{Euler_step, Any, Any}","page":"Numerical methods","title":"WavKinS.init_temporal_scheeme!","text":"init_temporal_scheeme!(::Euler_step, Run, dt)\n\nInitialization of the temporal scheeme.\n\nFirst argument is the time-stepping method: Euler_step, AB_Euler_step, AB2_RK2_step, RK2_step, ETD2_step, RK4_step, ETD4_step.\nRun: run structure\ndt: time step\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#Miscellaneous","page":"Numerical methods","title":"Miscellaneous","text":"","category":"section"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Unclassified numerical methods.","category":"page"},{"location":"numerical-methods.html","page":"Numerical methods","title":"Numerical methods","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/misc/WavKinS_misc.jl\"]","category":"page"},{"location":"numerical-methods.html#WavKinS.NewtonRaphson-Tuple{Any, Any}","page":"Numerical methods","title":"WavKinS.NewtonRaphson","text":"NewtonRaphson(f, x0; ϵ=1e-9, tol=1e-12, maxIter = 1000)\n\nFind the zero of the function f using the Newton-Raphson algorithm. \n\nx0: starting point\nϵ: spacing used to estimate derivative\ntol: tolerence\nmaxIter: maximal number of iterations\n\nAdapted from here.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.NewtonRaphson_with_derivative-Tuple{Any, Any, Any}","page":"Numerical methods","title":"WavKinS.NewtonRaphson_with_derivative","text":"NewtonRaphson_with_derivative(f, fp, x0, tol=1e-12, maxIter = 1000)\n\nSame as NewtonRaphson, but using the explicit derivative of f, which is the argument fp, instead of a numerical estimate.\n\n\n\n\n\n","category":"method"},{"location":"numerical-methods.html#WavKinS.cardano-Tuple{Float64, Float64}","page":"Numerical methods","title":"WavKinS.cardano","text":"cardano(p::Float64, q::Float64)\n\nAssuming that p > 0 and q < 0, it returns the positive real root of x^3 + p x + q. \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Acoustic.html#Acoustic2D-solver","page":"Acoustic","title":"Acoustic2D solver","text":"","category":"section"},{"location":"physical_systems/Acoustic.html#Description","page":"Acoustic","title":"Description","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"In this case, the collisional terms simpilfies to","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"St_k=frac2 pisqrt6a kint left(mathcalN^k_12-mathcalN^1_2k-mathcalN^2_k1right)mathrmdk_1mathrmdk_2","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"With mathcalN^k_12=V_k12^2(n_1n_2-n_1n_k-n_kn_2)delta(k-k_1-k_2) and V_k12=V_0sqrtkk_1k_2.","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"This is WKE results from assuming a disperse regularisation in the dispersion relation omega_k=ck(1+a^2k^2), with akll1. See Griffin et al., Phys. Rev. Lett. 128, 224501 (2022).","category":"page"},{"location":"physical_systems/Acoustic.html#Solver","page":"Acoustic","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The computation of the collision integral is relatively simple. We use the resonance condition k - k_1 - k_2 = 0 and the symmetry k_1 leftrightarrow k_2 to reduce the collision integral to","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"St_k = I_k - 2 J_k","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"where","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"I_k = frac2 pisqrt6a k intlimits_0^k  V_k12^2(n_1n_2-n_1n_k-n_kn_2)  mathrmdk_1","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"and","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"J_k = frac2 pisqrt6a k intlimits_k^k_rm max  V_k12^2(n_kn_2-n_kn_1-n_1n_2)  mathrmdk_1","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"with the integrands being computed using k_2 = k - k_1 and k_rm max the maximal wave vector modulus.","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The wave frequency is omega_k = ck and we use logarithmic grid wave_spectrum. The different options are described in the Acoustic2D documentation.","category":"page"},{"location":"physical_systems/Acoustic.html#Diagnostics","page":"Acoustic","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The standard diagnostics should work for this system.","category":"page"},{"location":"physical_systems/Acoustic.html#Theoretical-predictions","page":"Acoustic","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The Kolmogorov-Zakharov energy spectrum is ","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"e_k = 2pi k omega_k n_bf k = frac4^32 sqrta c3 pi  k^-1","category":"page"},{"location":"physical_systems/Acoustic.html#Acoustic3Dsolver","page":"Acoustic","title":"Acoustic3Dsolver","text":"","category":"section"},{"location":"physical_systems/Acoustic.html#Description-2","page":"Acoustic","title":"Description","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"In this case, the collisional terms simpilfies to","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"St_k=frac4 pi^2c k^2int left(mathcalN^k_12-mathcalN^1_2k-mathcalN^2_k1right)k_1 k_2 mathrmdk_1mathrmdk_2","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"With mathcalN^k_12=V_k12^2(n_1n_2-n_1n_k-n_kn_2)delta(k-k_1-k_2) and V_k12=V_0sqrtkk_1k_2.","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"This WKE describes 3D acoustic waves with frequency omega_k=ck. See Zakharov and Sagdeev, Dokl. Akad. Nauk SSSR 192, 297–300 (1970) and Kochurin and Kuznetsov, arXiv, 2407.08352, (2024).","category":"page"},{"location":"physical_systems/Acoustic.html#Solver-2","page":"Acoustic","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The computation of the collision integral is the same than for Acoustic2D solver, up to the prefactor. We use logarithmic grid wave_spectrum. The different options are described in the Acoustic3D documentation.","category":"page"},{"location":"physical_systems/Acoustic.html#Diagnostics-2","page":"Acoustic","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The standard diagnostics should work for this system.","category":"page"},{"location":"physical_systems/Acoustic.html#Theoretical-predictions-2","page":"Acoustic","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"The Kolmogorov-Zakharov energy spectrum is the Zakharov-Sagdeev (ZS) spectrum.","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"e_k = 4pi k^2 omega_k n_bf k = fracsqrtc P k^-32sqrt3pi(pi + 4 ln 2  1)","category":"page"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"with P the energy injection rate.","category":"page"},{"location":"physical_systems/Acoustic.html#List-of-structures-and-methods-for-Acoustic-solvers","page":"Acoustic","title":"List of structures and methods for Acoustic solvers","text":"","category":"section"},{"location":"physical_systems/Acoustic.html","page":"Acoustic","title":"Acoustic","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/Acoustic/basics.jl\", \"src/physical_systems/Acoustic/structure.jl\", \"src/physical_systems/Acoustic/collision_integral.jl\"]","category":"page"},{"location":"physical_systems/Acoustic.html#WavKinS.Acoustic2D","page":"Acoustic","title":"WavKinS.Acoustic2D","text":"Acoustic2D\n\nSimulation structure for Acoustic 2D wave turbulence. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\na::Float64 # dispersive length\nc::Float64 # speed of sound\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Acoustic.html#WavKinS.Acoustic2D-Tuple{wave_spectrum}","page":"Acoustic","title":"WavKinS.Acoustic2D","text":"Acoustic2D(Nk::wave_spectrum; a=0.5, c=1.0,interp_scheeme=lin_interp,time_stepping_scheeme=RK2_step)\n\nConstructor of a Acoustic2D structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme: lin_interp (default), powexp_interp, powGauss_interp, BS_interp\ntime_stepping_scheeme: Euler_step, RK2_step (default), RK4_step\n\nThe optional parameter a=0.5 and c=1.0 are the dispersive length and the speed of sound\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Acoustic.html#WavKinS.Acoustic3D","page":"Acoustic","title":"WavKinS.Acoustic3D","text":"Acoustic3D\n\nSimulation structure for Acoustic 3D wave turbulence. It contains\n\nname::string #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\nc::Float64 # speed of sound\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Acoustic.html#WavKinS.Acoustic3D-Tuple{wave_spectrum}","page":"Acoustic","title":"WavKinS.Acoustic3D","text":"Acoustic3D(Nk::wave_spectrum; a=0.5, c=1.0,interp_scheeme=lin_interp,time_stepping_scheeme=RK2_step\n\nConstructor of a Acoustic3D structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme: lin_interp (default), powexp_interp, powGauss_interp, BS_interp\ntime_stepping_scheeme: Euler_step, RK2_step (default), RK4_step\n\nThe parameter c=1.0 is the speed of sound\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Smoluchowski.html#Smoluchowskisolver","page":"Smoluchowski","title":"Smoluchowskisolver","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The Smoluchowski equation is a standard model of statistical physics. It describes coagulation processes such as droplets in clouds, blood clots, meteorite formation from stellar dust, and so on.","category":"page"},{"location":"physical_systems/Smoluchowski.html#Description","page":"Smoluchowski","title":"Description","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"In this case we use k for the particle mass and n_k is the particle density. The collision integral is ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"St_k = frac12 intlimits_0^k  K(k-pp)  n(k-pt)  n(pt)  mathrmdp -intlimits_0^infty  K(kp)  n(kt)  n(pt)  mathrmdp","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The coagulation kernel K(kp) describes the rate at which particles of mass k coagulate with particles of mass p. The constant, additive, and multiplicative kernels are defined as","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"K(kp) = 1  K(kp) = k + p  K(kp) = k p","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"respectively. These kernels are defined in src/physical_systems/Smoluchowski/basics.jl. Using other kernels is easy since K is passed as an element of the Smoluchowski structure. For more information about the Smoluchowski equation, you can refer to wikipedia.","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"Note that in the general case, there is only 1 integral to perform for each element of in mass space. Solving this equation will then require M^2 operation per time-step, where M is the number of discretization points of the mass space. It makes the simulation relatively cheap.","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"This wave kinetic equation conserves the total mass H","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"H = int k n_bf k dbf k","category":"page"},{"location":"physical_systems/Smoluchowski.html#Solver","page":"Smoluchowski","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html#Numerical-method","page":"Smoluchowski","title":"Numerical method","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The computation of the collision integral St_k is straightforward. We use logarithmic grid wave_spectrum. ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The different options are described in the Smoluchowski documentation.","category":"page"},{"location":"physical_systems/Smoluchowski.html#Using-the-Smoluchowski-solver","page":"Smoluchowski","title":"Using the Smoluchowski solver","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"As all the other WavKinS solvers, for Smoluchowski we need to create a Smoluchowski structure containing all the fields, working space, diagnostics, etc.  ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"using WavKinS\n\n# Create a waveaction structure containing the basic grid\nM = 1024 # set the number of nodes\nkmin = 5e-3 # minimal wave number\nkmax = 1e0 # maximal wave number\nNk = wave_spectrum(kmin, kmax, M)\n\n# Creating a NLS3D run structure with default parameters and multiplicative kernel.\nRun = Smoluchowski(Nk; K=WavKinS.K_Smoluchowski_multiplicative)","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"Note that the constructor allows to define the coagulation kernel in the structure so it is easy to use this solver to study many different physical systems. For example, you can investigate systems with kernels of the form K(kp) = (k p)^13 by using","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"function K_spec(k,p)\n    return (k*p)^(1/3)\nend\n\nRun = Smoluchowski(Nk; K=K_spec)","category":"page"},{"location":"physical_systems/Smoluchowski.html#Diagnostics","page":"Smoluchowski","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"This solver has the standard diagnostics.","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"warning: Warning\nFor consistency with other systems, we fix the \"wave frequency\" to the particle mass, i.e. omega_k = k. In that way, you can use basic diagnostics as for other solvers, but with a different meaning. For example, the \"energy\" energy is the total mass of particles and the \"energy flux\" energy_flux! is the mass flux.","category":"page"},{"location":"physical_systems/Smoluchowski.html#Testing-convergence-of-the-collisional-integral","page":"Smoluchowski","title":"Testing convergence of the collisional integral","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"WavKinS provide a simple test of the numerical convergence of the computation of the collisional integral. The testing script is located in /run/tests/physical_systems/tests_Smoluchowski.jl. ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"Theoretically, the collisional integral should conserve the mass, which means that","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"int_0^k_rm max St_k k dk=0","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The following numerical test evaluates those integrals and check the convergence to 0.","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"using WavKinS\n\nfunction nk_test(kk)\n    nk = kk^2 * exp(-kk / 50.0) / 250000\n    return nk\nend\n\nprintln(\"---------------------------------------------------------------------\")\nprintln(\"Testing collisional integral\")\nprintln(\"\")\n\nfor M ∈ 2 .^ (4:9)\n    kmin = 5e-3\n    kmax = 5e+3\n\n    Nk = wave_spectrum(kmin,kmax,M);\n    Run = Smoluchowski(Nk; K=WavKinS.K_Smoluchowski_one, interp_scheeme=WavKinS.lin_interp);\n\n    kk = Nk.kk\n    λ = Nk.λ\n  \n    @. Nk.nk = nk_test.(kk);\n\n    WavKinS.St_k!(Run)\n    \n    Flux = wave_spectrum(kmin,kmax,M)\n    @. Flux.nk = Run.Sk.nk .* Run.ω.(kk);\n    FluxNumH = integrate(Flux)\n\n    Ene = energy(Run)\n    \n    println(\"M in k= \", M, \", Integral flux num: dH/H=\", FluxNumH / Ene)\nend\n\nprintln(\"\")\nprintln(\"---------------------------------------------------------------------\")","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The output of this test is ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"---------------------------------------------------------------------\nTesting collisional integral\n\nM in k= 16, Integral flux num: dH/H=0.2848719543347318\nM in k= 32, Integral flux num: dH/H=0.04709845613146857\nM in k= 64, Integral flux num: dH/H=0.015286090880996035\nM in k= 128, Integral flux num: dH/H=0.003651780879324013\nM in k= 256, Integral flux num: dH/H=0.0009964865076014901\nM in k= 512, Integral flux num: dH/H=0.0002502083115315172\n\n---------------------------------------------------------------------","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"The solver conserves well the waveaction and errors on energy conservation roughly decreases as M^-2.","category":"page"},{"location":"physical_systems/Smoluchowski.html#Theoretical-predictions","page":"Smoluchowski","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"For kernel of the form K(kp) = a (kp)^xi2, the wave turbulence theory provides analytical prediction for out-of-equilibrium steady states obtained with forcing and dissipation, associated to a direct cascade of mass. The corresponding theoretical prediction are (see Connaughton et al., Phys. Rev. E 69, 061114 (2004) ):  ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"n_k=C_KZ^P P_0^12k^-(3+xi)2","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"where P_0 is mass flux, and the superscript P denotes the direct mass cascade. The theory also predicts the values of the dimensionless constant","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"C_KZ^P=frac1sqrt2 pi a","category":"page"},{"location":"physical_systems/Smoluchowski.html#Running-the-Smoluchowski-solver","page":"Smoluchowski","title":"Running the Smoluchowski solver","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"WavKinS provides a ready to use script to obtain out-of-equilibrium steady states of the WKE. The script is similar to the one presented in the tutorial and can be found in /run/simple/RunSimpleEvolution_Smoluchowski.jl. Running the script will generate the following plot exhibiting the steady state direct mass cascade. ","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"(Image: ) The dashed line is the theoretical prediction, with no adjustable parameters. The gelation process (see Ball et al., Phys. Rev. E 84, 011111 (2011) ), corresponding to a non-local transfer of small mass to large mass, explains the spectral bump at large mass.","category":"page"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"info: Info\nThe simulation took 39.1 seconds on a 2.30 GHz 8-Core 11th Gen Intel(R) Core(TM) i7-11800H, using 8 cores. ","category":"page"},{"location":"physical_systems/Smoluchowski.html#List-of-structures-and-methods-for-Smoluchowski-solver","page":"Smoluchowski","title":"List of structures and methods for Smoluchowski solver","text":"","category":"section"},{"location":"physical_systems/Smoluchowski.html","page":"Smoluchowski","title":"Smoluchowski","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/Smoluchowski/basics.jl\", \"src/physical_systems/Smoluchowski/structure.jl\", \"src/physical_systems/Smoluchowski/collision_integral.jl\"]","category":"page"},{"location":"physical_systems/Smoluchowski.html#WavKinS.Smoluchowski","page":"Smoluchowski","title":"WavKinS.Smoluchowski","text":"Smoluchowski\n\nSimulation structure for Smoluchowski. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Particle size\nK # Kernel\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Smoluchowski.html#WavKinS.Smoluchowski-Tuple{wave_spectrum}","page":"Smoluchowski","title":"WavKinS.Smoluchowski","text":"Smoluchowski(Nk::wave_spectrum; K=K_Smoluchowski_one, interp_scheeme=lin_interp,time_stepping_scheeme=RK2_step\n\nConstructor of a Smoluchowski structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme: lin_interp (default), powexp_interp, powGauss_interp, BS_interp\ntime_stepping_scheeme: Euler_step, RK2_step (default), RK4_step\n\nThe optional parameter K is the coagulation kernel.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"We use structures for storing grids, dissipation coefficients, parameters, diagnostics, etc. For all physical systems, we define a general structure containing all variables and parameters necessary for a simulation (see e.g. Acoustic2D).","category":"page"},{"location":"basics.html#Structures","page":"Basics","title":"Structures","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/WavKinS_structures.jl\"]","category":"page"},{"location":"basics.html#WavKinS.diagnostic_container","page":"Basics","title":"WavKinS.diagnostic_container","text":"Structure containing diagnostics, spectra, etc.\n\nglob_diag::Dict{String, global_ouput} # dictionary with global outputs\nsp_outs::Dict{String, spectral_output} # dictionary with spectral outputs\nsp_store::Dict{String, Array{Float64}} # dictionary with stored in memory spectral quantities\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.diagnostic_container-Tuple{Int64, Int64}","page":"Basics","title":"WavKinS.diagnostic_container","text":"function diagnostic_container(Mh::Int, Mz::Int)\n\nConstructor of a diagnostic_container for wave_spectrum_khkz with Mh and Mz points.  Same ininitialisation as diagnostic_container(M::Int).\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.diagnostic_container-Tuple{Int64}","page":"Basics","title":"WavKinS.diagnostic_container","text":"function diagnostic_container(M::Int)\n\nConstructor of a diagnostic_container for a wave_spectrum with M points.\n\nThe dictionaries are initialised by default with standard outputs:\nglob_diag : It contains the keys \"Times\", \"H\", \"N\", and \"Disp\":\n    \"Times\" => \"Times of global quantities\"\n    \"H\" => \"Total energy\"  \n    \"N\" => \"Total wave action\"  \n    \"Disp\" => \"\"Total dissipation\"\"    \n\nsp_outs : It contains the keys \"nk\", \"Ek\", and \"Pk\"\n    \"nk\" => \"Wave action spectrum\"\n    \"Ek\" => \"Energy spectrum\"\n    \"Pk\" => \"Energy flux\"\n\nsp_store : It contains the keys \"nk\", \"Pk\", and \"Tsp\"\n    \"nk\" => \"Wave action spectrum\"\n    \"Pk\" => \"Energy spectrum\"\n    \"Tsp\" => \"Times of stored spectra\"\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.field_grid_1D","page":"Basics","title":"WavKinS.field_grid_1D","text":"Basic structure for a 1D field defined on an arbitrary grid. \n\nM::Int: number of grid points\nkk::Vector{Float64}: grid\nF::Vector{Float64}: field\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.field_grid_1D-Tuple{Vector{Float64}}","page":"Basics","title":"WavKinS.field_grid_1D","text":"field_grid_1D(kk::Vector{Float64})\n\nConstructor of the field_grid_1D structure. \n\nkk: grid\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.force_dissipation","page":"Basics","title":"WavKinS.force_dissipation","text":"Structure for storing forcing and dissipation coefficients f_bf k and d_bf k.\n\nf::VecOrMat{Float64} # forcing of the WKE\nD::VecOrMat{Float64} # dissipation of the WKE\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.force_dissipation-Tuple{Int64, Int64}","page":"Basics","title":"WavKinS.force_dissipation","text":"force_dissipation(Mh::Int, Mz::Int)\n\nConstructor of force_dissipation for axisymmetric or 2D systems.\n\nMh: number of horizontal wave vector grid points \nMz: number of vertical wave vector grid points\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.force_dissipation-Tuple{Int64}","page":"Basics","title":"WavKinS.force_dissipation","text":"force_dissipation(M::Int)\n\nConstructor of force_dissipation for isotropic or 1D systems.\n\nM: number of wave vector grid points \n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.global_ouput","page":"Basics","title":"WavKinS.global_ouput","text":"Basic structure for storing a global variable. \n\nlongname::string  # long name\nout::Vector{Float64} # vector containing the output\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.global_ouput-Tuple{Any}","page":"Basics","title":"WavKinS.global_ouput","text":"global_ouput(longname)\n\nConstructor of a global_output. \n\nlongname: long name of the global variable\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.kinematic_box","page":"Basics","title":"WavKinS.kinematic_box","text":"Basic structure for a kinematic box with p and q variables.  (Image: ) We use a such that p=a-k_h  -k_h0 or p=k_h-a  0k_h.  Note: The horizontal wave vectors of first and second waves are k_1h = (k_h + p + q)2 and k_2h = (k_h - p + q)2.\n\nMa::Vector{Int} # number of points in a (depends on kh)\nMq::Int # number of points in q \nλa::Vector{Float64} # logarithmic increment of the meshes in a (depends on kh)\nλq::Float64 # logarithmic increment of the mesh in q\nlogλa::Vector{Float64} # log(λa)\nlogλq::Float64 # log(λq)\naa::Vector{Vector{Float64}} # meshes of a (depends on kh)\nqq::Vector{Float64} # mesh of q\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.kinematic_box-Tuple{Vector{Float64}, Vector{Float64}, Vector{Int64}, Float64, Float64, Int64}","page":"Basics","title":"WavKinS.kinematic_box","text":"kinematic_box(amin::Vector{Float64}, amax::Vector{Float64}, Ma::Vector{Int}, qmin::Float64, qmax::Float64, Mq::Int)\n\nConstructor of a kinematic_box structure. \n\namin: minimal value of a (depends on k_h)\namax: maximal value of a (depends on k_h)\nMa: number of grid points in a (depends on k_h)\nqmin: minimal value of q\nqmax: maximal value of q\nMq: number of grid points in q\n\nThe a grid points are ai = a_rm min λ_a^i-1 where λ_a is the logarithmic increment such that aM_a = a_rm max. The q grid points are qi = q_rm min λ_q^i-1 where λ_q is the logarithmic increment such that qM_q = q_rm max.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.spectral_output","page":"Basics","title":"WavKinS.spectral_output","text":"Basic structure for storing a spectrum. \n\nlongname::String  # long name of the variable\nsp::VecOrMat{Float64}  # spectrum\nwrite_sp::Bool # write and compute this spectrum\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.spectral_output-Tuple{String, Int64, Int64}","page":"Basics","title":"WavKinS.spectral_output","text":" spectral_output(longname,Mh, Mz)\n\nConstructor of a spectral_output for axisymmetric or 2D systems.\n\nlongname: long name of the spectrum\nMh: number of horizontal wave vector grid points \nMz: number of vertical wave vector grid points\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.spectral_output-Tuple{String, Int64}","page":"Basics","title":"WavKinS.spectral_output","text":" spectral_output(longname,M)\n\nConstructor of a spectral_output for isotropic or 1D systems.\n\nlongname: long name of the spectrum\nM: number of wave vector grid points \n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.wave_spectrum","page":"Basics","title":"WavKinS.wave_spectrum","text":"Basic structure for an isotropic or 1D field with logarithmic grid. \n\nM::Int # number of points\nnk::Vector{Float64} # wave action\nλ::Float64 # logarithmic increment of the mesh\nlogλ::Float64 # log(λ)\nkk::Vector{Float64} # wave vector\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.wave_spectrum-Tuple{Float64, Float64, Int64}","page":"Basics","title":"WavKinS.wave_spectrum","text":"wave_spectrum(kmin::Float64, kmax::Float64, M::Int)\n\nConstructor of a wave_spectrum structure. \n\nkmin: minimal wave vector \nkmax: maximal wave vector\nM: number of grid points\n\nThe wave vector grid points are ki = k_rm min λ^i-1 where λ is the logarithmic increment such that kM = k_rm max.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.wave_spectrum_khkz","page":"Basics","title":"WavKinS.wave_spectrum_khkz","text":"Basic structure for an axisymmetric or 2D (with k_z  -k_z symmetry) spectrum. \n\nMh::Int # number of points in the horizontal\nMz::Int # number of points in the vertical \nnk::Array{Float64,2} # wave action\nλh::Float64 # logarithmic increment of the mesh in the horizontal\nλz::Float64 # logarithmic increment of the mesh in the vertical\nlogλh::Float64 # log(λh)\nlogλz::Float64 # log(λz)\nkkh::Vector{Float64} # horizontal wave vector modulus\nkkz::Vector{Float64} # vertical wave vector modulus\nkk::Array{Float64,2} # wave vector modulus\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.wave_spectrum_khkz-Tuple{Float64, Float64, Int64, Float64, Float64, Int64}","page":"Basics","title":"WavKinS.wave_spectrum_khkz","text":"wave_spectrum_khkz(khmin::Float64, khmax::Float64, Mh::Int, kzmin::Float64, kzmax::Float64, Mz::Int)\n\nConstructor of a wave_spectrum_khkz structure. \n\nkhmin: minimal horizontal wave vector \nkhmax: maximal horizontal wave vector\nMh: number of horizontal wave vector grid points\nkzmin: minimal vertical wave vector \nkzmax: maximal vertical wave vector\nMz: number of vertical wave vector grid points\n\nThe horizontal wave vector grid points are k_hi_h = k_h rm min λ_h^i_h-1 where λ_h is the logarithmic increment such that k_hM_h = k_h rm max. The vertical wave vector grid points are k_zi_z = k_z rm min λ_z^i_z-1 where λ_z is the logarithmic increment such that k_zM_z = k_z rm max.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#Parameters","page":"Basics","title":"Parameters","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/WavKinS_parameters.jl\"]","category":"page"},{"location":"basics.html#WavKinS.simulation_parameters","page":"Basics","title":"WavKinS.simulation_parameters","text":"Basic structure containing information about the simulation.\n\ndt::Float64 # time step of the simulation\ntplot::Float64 # Plot every tplot times\ntglobal::Float64 # Compute, store and write global quantities every tglobal times \ntspstore::Float64 # Compute and store spectral quantities every tspstore times\ntspwrite::Float64 # write spectra every tspwrite\n\noutputDir::String #output directory\nwrite_global::Bool #write global\nwrite_spectral::Bool #write spectra\n\n\n\n\n\n","category":"type"},{"location":"basics.html#WavKinS.simulation_parameters-NTuple{4, Any}","page":"Basics","title":"WavKinS.simulation_parameters","text":"simulation_parameters(dt,tplot,tglobal,tspstore)\n\nConstructor for simulation_parameters structure.\n\ndt: time step of the simulation\ntplot: plot every tplot times\ntglobal: compute, store and write global quantities every tglobal times \ntspstore: compute and store spectral quantities every tspstore times\n\n\n\n\n\n","category":"method"},{"location":"basics.html#Diagnostics","page":"Basics","title":"Diagnostics","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/WavKinS_diagnostics.jl\"]","category":"page"},{"location":"basics.html#WavKinS.compute_spectral!-Tuple{Any}","page":"Basics","title":"WavKinS.compute_spectral!","text":"compute_spectral!(Run)\n\nCompute and store default current spectral quantities\n\nRun: WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_outs the default spectral quantities: the waveaction, energy, and the energy fluc spectra. This routine is typically called from compute_spectral!(Run) which might add additional spectra for each physical system.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.density_dissipation","page":"Basics","title":"WavKinS.density_dissipation","text":"density_dissipation(Run, ρ=one)\n\nCompute total dissipation weighted by the density  rho as  int d_bf k rho_bf k n_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf kand the dissipation coefficients d_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.density_flux!","page":"Basics","title":"WavKinS.density_flux!","text":" density_flux!(Pk::AbstractVector, Run,ρ=one)\n\nCompute flux of a density rho. For isotropic systems, it is P(k) = - intlimits_bf kk rho_bf k St_bf k mathrmdbf k.\n\nPk: AbstractVector where flux is stored\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.density_flux_angular!","page":"Basics","title":"WavKinS.density_flux_angular!","text":"density_flux_angular!(thk::AbstractVector, Pthk::AbstractVector, Run, ρ=one)\n\nCompute angular flux of a density rho. It is P(theta_bf k) = - intlimits_theta_bf ktheta_bf k rho_bf k St_bf k mathrmdbf k.\n\nthk: AbstractVector for the angles grid\nPthk: AbstractVector where flux is stored\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.density_flux_isotropic!","page":"Basics","title":"WavKinS.density_flux_isotropic!","text":"density_flux_isotropic!(Pk::AbstractVector, Run,ρ=one)\n\nCompute isotric (after sum over angle) flux of a density rho. It is P(k) = - intlimits_bf kk rho_bf k St_bf k mathrmdbf k.\n\nPk: AbstractVector where flux is stored\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.density_injection","page":"Basics","title":"WavKinS.density_injection","text":"density_injection(Run, ρ=one)\n\nCompute total injection weighted by the density  rho as  int rho_bf k f_bf k mathrmdbf k.    \n\nRun: WavKinS simulation structure containing the wave action n_bf k and the forcing coefficients f_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.density_spectrum!","page":"Basics","title":"WavKinS.density_spectrum!","text":"density_spectrum!(Ek::Union{AbstractVector,AbstractMatrix}, Run, ρ=one)\n\nCompute spectrum of a quantity with spectral density rho. For isotropic systems, it is s(k) = rho_bf k n_bf k k^d-1 mathrmdOmega. For axisymmetric systems, it is s(k_hk_z) = rho_bf k n_bf k k_h^d-1 mathrmdOmega.\n\nEk: where spectrum is stored\nRun: WavKinS simulation structure containing the wave action n_bf k, physical dimension d and surface of the unit sphere (or of the isotropic sector) mathrmdΩ\nρ: density. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.energy-Tuple{Any}","page":"Basics","title":"WavKinS.energy","text":"energy(Run)\n\nCompute total energy int omega_bf k n_bf k mathrmdbf k. \n\nRun: WavKinS simulation structure containing the wave action n_bf k and the dispersion relation omega_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.energy_conservation_ratio-Tuple{Any}","page":"Basics","title":"WavKinS.energy_conservation_ratio","text":"energy_conservation_ratio(Run)\n\nCompute the ratio fracleft int omega_bf k St_bf k mathrmdbf k rightint omega_bf k St_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k, the dispersion relation omega_bf k and the collision integral St_bf k\n\nNote: If the energy is a dynamical invariant, this ratio must tends to zero as the resolution increases (see Eden et al., J. Phys. Oceanogr. 49, 737-749 (2019)).\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.energy_dissipation-Tuple{Any}","page":"Basics","title":"WavKinS.energy_dissipation","text":"energy_dissipation(Run)\n\nCompute total energy dissipation of the system int d_bf k omega_bf k n_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k, the dispersion relation omega_bf k and the dissipation coefficients d_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.energy_flux!-Tuple{AbstractVector, Any}","page":"Basics","title":"WavKinS.energy_flux!","text":"energy_flux!(Pk::AbstractVector, Run)\n\nCompute energy flux. For isotropic systems, it is P(k) = - intlimits_bf kk omega_bf k St_bf k mathrmdbf k.\n\nPk: where energy flux is stored\nRun: WavKinS simulation structure containing the wave action n_bf k and dispersion relation omega_rm k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.energy_injection-Tuple{Any}","page":"Basics","title":"WavKinS.energy_injection","text":"energy_injection(Run)\n\nCompute total energy injection of the system int omega_bf k f_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k, the dispersion relation omega_bf k and the forcing coefficients f_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.energy_spectrum!-Tuple{Union{AbstractMatrix, AbstractVector}, Any}","page":"Basics","title":"WavKinS.energy_spectrum!","text":"energy_spectrum!(Ek::Union{AbstractVector,AbstractMatrix},Run,ρ=one)\n\nCompute energy spectrum. \n\nEk: where energy spectrum is stored\nRun: WavKinS simulation structure containing the wave action n_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.get_global_diagnostics!-Tuple{Any}","page":"Basics","title":"WavKinS.get_global_diagnostics!","text":"get_global_diagnostics(Run)\n\nCompute default global diagnostics\n\nRun: WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.glob_diag the default diagnostics: The current time, the total waveaction, the total energy, and the total dissipation.\n\nThis routine is typically called from get_global_diagnostics(Run) which might add additional diagnostics for each physical system.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.isotropic_density_spectrum!","page":"Basics","title":"WavKinS.isotropic_density_spectrum!","text":"isotropic_density_spectrum!(Run, ρ=one)\n\nCompute isotropic spectrum of a quantity with spectral density rho as s(k) = frac1mathrmdk intlimits_bf k=k^k+mathrmdk rho_bf k n_bf k mathrmdbf k. \n\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.kh_density_spectrum!","page":"Basics","title":"WavKinS.kh_density_spectrum!","text":"kh_density_spectrum!(Run, ρ=one)\n\nFor axisymmetric systems, compute k_h spectrum (after average over k_z) of a quantity with spectral density rho. \n\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.kz_density_spectrum!","page":"Basics","title":"WavKinS.kz_density_spectrum!","text":"kz_density_spectrum!(Run, ρ=one)\n\nFor axisymmetric systems, compute k_z spectrum (after average over k_h) of a quantity with spectral density rho. \n\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.store_spectral!-Tuple{Any}","page":"Basics","title":"WavKinS.store_spectral!","text":"store_spectral!(Run)\n\nCompute and store default spectral quantities\n\nRun: WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_store the default spectral quantities: the waveaction and the energy fluc spectrum. This routine is typically called from store_spectral(Run) which might add additional spectra for each physical system.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.total_density_abs_flux","page":"Basics","title":"WavKinS.total_density_abs_flux","text":"total_density_abs_flux(Run,ρ)\n\nCompute sum of the absolute value of the flux weighted by the density rho as int rho_bf k St_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k and the collision integral St_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.total_density_flux","page":"Basics","title":"WavKinS.total_density_flux","text":"total_density_flux(Run,ρ)\n\nCompute sum of the flux weighted by the density rho as int rho_bf k St_bf k mathrmdbf k.    \n\nRun: WavKinS simulation structure containing the wave action n_bf k and the collision integral St_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\nNote: Ideally, it should be zero for a dynamical invariant (e.g. energy should be conserved for Acoustic, Petviashvilli, Strat_Asymp, ...).\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.total_entropy-Tuple{Any}","page":"Basics","title":"WavKinS.total_entropy","text":"total_entropy(Run)\n\nCompute total wave action entropy int log(n_bf k) mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.total_integral_density","page":"Basics","title":"WavKinS.total_integral_density","text":"total_integral_density(Run,ρ)\n\nCompute total integral weighted by the density rho as int rho_bf k n_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k\nρ: a function defining the weight of the integral. By default ρ()=1\n\n\n\n\n\n","category":"function"},{"location":"basics.html#WavKinS.total_waveaction-Tuple{Any}","page":"Basics","title":"WavKinS.total_waveaction","text":"total_waveaction(Run)\n\nCompute total wave action int n_bf k mathrmdbf k. \n\nRun: WavKinS simulation structure containing the wave action n_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.waveaction_dissipation-Tuple{Any}","page":"Basics","title":"WavKinS.waveaction_dissipation","text":"waveaction_dissipation(Run)\n\nCompute total wave action dissipation of the system int d_bf k n_bf k mathrmdbf k.\n\nRun: WavKinS simulation structure containing the wave action n_bf k and the dissipation coefficients d_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.waveaction_flux!-Tuple{AbstractVector, Any}","page":"Basics","title":"WavKinS.waveaction_flux!","text":"waveaction_flux!(Qk::AbstractVector, Run)\n\nCompute waveaction flux. For isotropic systems, it is P(k) = - intlimits_bf kk St_bf k mathrmdbf k.\n\nQk: where energy flux is stored\nRun: WavKinS simulation structure containing the wave action n_bf k\n\n\n\n\n\n","category":"method"},{"location":"basics.html#Outputs","page":"Basics","title":"Outputs","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/WavKinS_outputs.jl\"]","category":"page"},{"location":"basics.html#WavKinS.init_IO-Tuple{Any, String}","page":"Basics","title":"WavKinS.init_IO","text":"init_IO(Run, outputDir::String)\n\nInputs/Outputs initialization.\n\nRun: WavKinS simulation structure\noutputDir: path of the output directory \n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.load_spectral_for_change_mesh!-Tuple{wave_spectrum, String, Any}","page":"Basics","title":"WavKinS.load_spectral_for_change_mesh!","text":"load_spectral_for_change_mesh!(Nk::wave_spectrum, datafile::String, Run; irestart=-1)\n\nLoad wave action spectrum to change the mesh.\n\nRun: WavKinS simulation structure\ndatafile: path of the output file  \nirestart: time step\n\nBy default, it loads the spectrum at the latest time step.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.load_spectrum-Tuple{Any, String}","page":"Basics","title":"WavKinS.load_spectrum","text":"load_spectrum(Run, outputDir::String; irestart=-1)\n\nLoad wave action spectrum.\n\nRun: WavKinS simulation structure\noutputDir: path of the output directory   \nirestart: time step\n\nBy default, it loads the spectrum at the latest time step.\n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.output_global-Tuple{Any, String}","page":"Basics","title":"WavKinS.output_global","text":"output_global(Run, outputDir::String)\n\nWrite global output (total wave action, total energy, ...).\n\nRun: WavKinS simulation structure\noutputDir: path of the output directory  \n\n\n\n\n\n","category":"method"},{"location":"basics.html#WavKinS.output_spectra-Tuple{Any, String}","page":"Basics","title":"WavKinS.output_spectra","text":"output_spectra(Run, outputDir::String)\n\nWrite spectra.\n\nRun: WavKinS simulation structure\noutputDir: path of the output directory   \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#Stratified_Asympsolver","page":"Stratified","title":"Stratified_Asympsolver","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Internal Gravity Waves (IGW) propagate in stratified flows like the oceans and atmospheres. They are therefore important for geophysical applications (see Lvov et al., J. Phys. Oceanogr. 42, 669–691 (2012) for a review). The Stratified_Asymp solver is for the kinetic equation of IGW in the strong anisotropy (or hydrostatic) limit, where we consider that the horizontal wave vector k_h is small compared to the vertical wave vector k_z.   ","category":"page"},{"location":"physical_systems/Stratified.html#Description","page":"Stratified","title":"Description","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"In the solver, we consider the WKE of 3D-internal waves dotn_bf k=St_k. We consider that n_bf k is isotropic in the plane perpendicular to the gravity (the z-axis), and therefore it is a function of the magnitude of the horizontal wavevector k_h and the vertical wavavector k_z only. It explicitly reads","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"St_bf k = 8 pi  int  left mathcalR^k_12 - mathcalR^1_k2 - mathcalR^2_k1 right  k_1h k_2h  mathrmd k_1h mathrmd k_2h","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"where","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"mathcalR^k_12 = fracV_k12^2g Delta left( n_1 n_2 - n_bf k n_1 - n_bf k n_2 right)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"the interaction coefficients are","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"V_k12 = sqrtfrack_h k_1h k_2h32 left( fracbf k_h cdot bf k_1hk_h k_1h sqrtleft frack_2zk_z k_1z right + fracbf k_h cdot bf k_2hk_h k_2h sqrtleft frack_1zk_z k_2z right + fracbf k_1h cdot bf k_2hk_1h k_2h sqrtleft frack_zk_1z k_2z right right)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"the determinant is","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Delta = frac12 sqrt(- k_h + k_1h + k_2h) (k_h - k_1h + k_2h) (k_h + k_1h - k_2h) (k_h + k_1h + k_2h)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"and ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"g = frack_1h rm sign(k_1z)k_1z^2 - frack_2h  rm sign(k_2z)k_2z^2","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"This WKE results from assuming axisymmetry around the stratification axis bf e_z. The dispersion relation is","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"omega_k=N k_hk_z","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"with N the buoyancy frequency. k_1z, k_2z are given by the solution of the resonance conditions, i.e. the joint conservation of momentum and energy in each triadic interaction (bf k = bf k_1 + bf k_2 and omega_k = omega_1 + omega_2 for mathcalR^k_12 and so on). See Lvov and Tabak, Phys. Rev. Lett. 87, 168501 (2001),  Dematteis and Lvov, JFM 915, A129 (2021) and Labarre et al., arXiv, 2407.11469 (2024).","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"This wave kinetic equation conserves the total energy ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"H = int omega_bf k n_bf k dbf k","category":"page"},{"location":"physical_systems/Stratified.html#Solver","page":"Stratified","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Stratified.html#Numerical-method","page":"Stratified","title":"Numerical method","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"We use the symmetry k_1 leftrightarrow k_2 to write the collision integral as","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"St_bf k = St(k_hk_z) = 4 pi int  fracL(pq)Delta(pq)  mathrmdp mathrmdq","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The integral is performed over the kinematic box (pq) in -k_hk_h times 0q_rm max, q_rm max being a cut-off (=2k_hrm max by default). the kinematic box depends on k_h so you can change the number of grid points and cut-offs for each k_h. See kinematic_box for more details.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"We use the method L_vs to compute the term","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"L(pq) = left fracV_k12^2g left( n_1 n_2 - n_bf k n_1 - n_bf k n_2 right) k_1h k_2h right_R_k - 2 left fracV_k12^2g left( n_1 n_2 - n_bf k n_1 - n_bf k n_2 right) k_1h k_2h right_R_1","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"where we use the notation R_k (respectively R_1) to indicate that the terms are evaluated on the resonant manifold bf k = bf k_1 + bf k_2, omega_bf k = omega_1 + omega_2 (respectively bf k_1 = bf k + bf k_2, omega_1 = omega_bf k + omega_2). For each case (R_k or R_1), there are two branches, i.e. two solutions for k_1z that coded in k1zkp_vs, k1zkm_vs, k1z1p_vs and k1z1m_vs.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The denominator","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Delta(pq) = frac12 sqrt(k_h^2-p^2) q (2 k_h+q)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"is zero at the borders of the kinematic box p = pm k_h and/or q=0, leading to integrable singularities that must be treated for accurate results.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"For the contribution of the grid points with q = 0, we use","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"intlimits_0^delta k_h  fracL(pq)Delta(pq)  mathrmdq simeq L(pdelta k_h) sqrt frac2 deltak_h^2-p^2","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"with delta ll 1.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"For the contribution of the grid points with p = -k_h, we use ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"intlimits_-k_h^(-1+xi) k_h  fracL(pq)Delta(pq)  mathrmdp simeq L((-1+xi)k_hq) sqrtfrac2 xiq(2k_h+q)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"with xi ll 1. The contribution of grid points with p = k_h is computed in the same way.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"For the two grid points with p = pm k_h and q=0, we use","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"intlimits_0^delta k_h intlimits_pm k_h^pm(-1+xi) k_h  fracL(pq)Delta(pq)  mathrmdp mathrmdq simeq  L(pm(-1+xi) k_hdelta k_h) 2 left( pi - 2 arcsin (1-xi) right) arcsin left( sqrtdelta2 right)","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"We use the logarithmic two-dimensional grid wave_spectrum_khkz to represent the waveaction spectrum n_bf k. The different options are described in the Stratified_Asymp documentation.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Note the if we use M nodes to represent each coordinate of the Fourier space, then, the numerical cost of computing the collisional integral is of the order of M^4 operations, which is prohibitive. Well resolved numerical simulations with this solver therefore requires clusters.","category":"page"},{"location":"physical_systems/Stratified.html#Using-the-Stratified_Asymp-solver","page":"Stratified","title":"Using the Stratified_Asymp solver","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"As all the other WavKinS solvers, we need to create a Stratified_Asymp structure containing all the fields, working space, diagnostics, etc.  ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"using WavKinS\n\n# Create a waveaction structure containing the basic grid\nMh = 16 # set the number of nodes for horizontal wave number\nMz = 16 # set the number of nodes for vertical wave number\nkhmin = 5e-3 # minimal horizontal wave number\nkhmax = 1e0 # maximal horizontal wave number\nkzmin = 5e-3 # minimal vertical wave number\nkzmax = 1e0 # maximal vertical wave number\nNk = wave_spectrum_khkz(khmin,khmax,Mh,kzmin,kzmax,Mz)\n\n# Creating a Stratified_Asymp run structure with default parameters.\nRun = WavKinS.Stratified_Asymp(Nk);","category":"page"},{"location":"physical_systems/Stratified.html#Diagnostics-and-special-post-processing","page":"Stratified","title":"Diagnostics and special post-processing","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The standard diagnostics should work for this system. ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"In src/physical_systems/Stratified/special.jl, we also have implemented other methods to compute and plot spectra using other coordinates. ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The function compute_ωkz_spectrum computes the (omega_bf kksimeq k_z) spectrum, which is widely used in oceanographic studies (Olbers et al., J. Phys. Oceanogr. 50, 751-771 (2020)).","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The function compute_ξkz_spectrum computes the (xi_bf kequiv k_hk_z^2k_z) spectrum.  xi_bf k simeq xi_1 simeq xi_2 for Induced Diffusion interactions (Lanchon and Cortet, Phys. Rev. Lett. 131, 264001 (2023)), so the spectrum develops along iso-xi_bf k lines.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"We also have implemented functions for plotting these spectra.","category":"page"},{"location":"physical_systems/Stratified.html#Testing-convergence-of-the-collisional-integral","page":"Stratified","title":"Testing convergence of the collisional integral","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"WavKinS provide a simple test of the numerical convergence of the computation of the collisional integral. The testing script is located in /run/tests/physical_systems/tests_Stratified_Asymp.jl. ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Theoretically, the collisional integral should conserve the waveaction and the energy, which means that","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"2 times 2 pi int_0^k_hrm max int_0^k_zrm max  omega_bf k St_bf k k_h mathrmdk_h mathrmdk_z = 0","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The following numerical test evaluates those integrals and check the convergence to 0.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"using WavKinS\n\nfunction nk_test(kh,kz)\n    return abs(kz^2)*exp(-kh - abs(kz)) * kh^1.5/(1. + abs(kz))/118\nend\n\nprintln(\"---------------------------------------------------------------------\")\nprintln(\"Testing collisional integral\")\nprintln(\"\")\n\nfor j = 3:7\n    Mh = 2^j\n    Mz = 2^j\n    khmin = 1e-2\n    khmax = 1e2\n    kzmin = 1e-2\n    kzmax = 1e2\n \n    Nk = wave_spectrum_khkz(khmin,khmax,Mh,kzmin,kzmax,Mz)\n    Run = Stratified_Asymp(Nk; interp_scheeme=WavKinS.bilin_interp_khkz, integ_scheeme=integrate_with_log_bins_khkz)\n\n    kkh = Nk.kkh\n    kkz = Nk.kkz\n    kk = Nk.kk\n    KKH = kkh .* ones(length(kkz))'\n    KKZ = ones(length(kkh)) .* kkz'\n    @. Nk.nk = nk_test.(KKH, KKZ);\n\n    WavKinS.St_k!(Run)\n\n    Flux = wave_spectrum_khkz(khmin,khmax,Mh,kzmin,kzmax,Mz)\n    @. Flux.nk = Run.Sk.nk * Run.ω.(KKH, KKZ) * KKH * Run.dΩ;\n\n    Ene = energy(Run)\n    FluxNumH = total_density_flux(Run, Run.ω)    \n    \n    println(\"Mh = \", Mh, \", Mz = \", Mz, \", Integral flux num: dH/H=\", FluxNumH / Ene)\nend\n\nprintln(\"\")\nprintln(\"---------------------------------------------------------------------\")","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The output of this test is ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"---------------------------------------------------------------------\nTesting collisional integral for energy conservation\n\nMh = 8, Mz = 8, Integral flux num: dH/H=253.3645103905745\nMh = 16, Mz = 16, Integral flux num: dH/H=3.377632098174059\nMh = 32, Mz = 32, Integral flux num: dH/H=0.5714735429013132\nMh = 64, Mz = 64, Integral flux num: dH/H=0.12038700544323301\nMh = 128, Mz = 128, Integral flux num: dH/H=0.026346960726081035\n\n---------------------------------------------------------------------","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"We see that the error on energy conservation roughly decreases as M^-2.","category":"page"},{"location":"physical_systems/Stratified.html#Theoretical-predictions","page":"Stratified","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"The only power law steady spectrum was found numerically (see Lvov et al., J. Phys. Oceanogr. 40, 2605-2623 (2010))","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"n_bf k propto k_h^-369 k_z^0","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Yet, any perturbation of the k_z exponent would lead to a divergence of the collision integral, making the realizability of this spectrum unclear.","category":"page"},{"location":"physical_systems/Stratified.html#Running-the-Stratified_Asymp-solver","page":"Stratified","title":"Running the Stratified_Asymp solver","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"WavKinS provides a ready to use script to obtain out-of-equilibrium steady states of the WKE. The script is similar to the one presented in the tutorial and can be found in /run/simple/RunSimpleEvolution_Stratified_Asymp.jl. ","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"warning: Warning\nThis script runs a simulation with very coarse resolution M_h = M_z = M = 16. Even resolution M simeq 40 requires supercomputers due to the M^4 numerical cost.","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Running a similar script in a HPC cluster using 128 cores and a resolution of M=80 takes several weeks. The results is displayed in the figure (Image: )","category":"page"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"On the left, we observe a very early stage spectrum where only wavectors close to the forcing are excited. On the right, the spectrum is well developed and the system is close to a steady state.","category":"page"},{"location":"physical_systems/Stratified.html#List-of-structures-and-methods-for-Stratified-solvers","page":"Stratified","title":"List of structures and methods for Stratified solvers","text":"","category":"section"},{"location":"physical_systems/Stratified.html","page":"Stratified","title":"Stratified","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/Stratified/basics.jl\", \"src/physical_systems/Stratified/structure.jl\", \"src/physical_systems/Stratified/collision_integral.jl\", \"src/physical_systems/Stratified/diagnostics.jl\", \"src/physical_systems/Stratified/special.jl\"]","category":"page"},{"location":"physical_systems/Stratified.html#WavKinS.L_vs-NTuple{7, Any}","page":"Stratified","title":"WavKinS.L_vs","text":"L_vs(ih,iz,p,q,Nk,val_nk,interp_scheeme)\n\nIntegrand of the collision integral multiplied by Δ.\n\nih, iz: external wave vector indices\np, q: coordinates on the kinematic box\nNk: wave action spectrum\nval_nk, interp_scheeme: used for interpolation\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.V1_Strat_Asymp-NTuple{6, Any}","page":"Stratified","title":"WavKinS.V1_Strat_Asymp","text":"V1_Strat_Asymp(kh,kz,k1h,k1z,k2h,k2z)\n\nInteraction coefficient on the resonant manifold bf k_1 = bf k + bf k_2, omega_1 = omega_bf k + omega_2 \n\nkh, k1h, k2h: horizontal wave vector modulus\nkz, k1z, k2z: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.Vk_Strat_Asymp-NTuple{6, Any}","page":"Stratified","title":"WavKinS.Vk_Strat_Asymp","text":"Vk_Strat_Asymp(kh,kz,k1h,k1z,k2h,k2z)\n\nInteraction coefficient on the resonant manifold bf k = bf k_1 + bf k_2, omega_bf k = omega_1 + omega_2 \n\nkh, k1h, k2h: horizontal wave vector modulus\nkz, k1z, k2z: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.dg_vs-NTuple{4, Any}","page":"Stratified","title":"WavKinS.dg_vs","text":"dg_vs(k1h,k1z,k2h,k2z)\n\nJacobian arizing from resonance in frequency:\n\ng = k_1h rm sign(k_1z)k_1z^2 - k_2h rm sign(k_2z)k_2z^2\n\nk1h, k2h: horizontal wave vector modulus\nk1z, k2z: vertical wave vectors\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.k1z1m_vs-NTuple{4, Any}","page":"Stratified","title":"WavKinS.k1z1m_vs","text":"k1z1m_vs(kh,kz,k1h,k2h)\n\nk_1z solution of bf k_1 = bf k + bf k_2, omega_1 = omega_bf k + omega_2 (branch -):\n\nk_1z = frack_z2k_h left( k_h - k_1h + k_2h - sqrt (-k_h + k_1h - k_2h)^2 + 4 k_h k_1h  right)\n\nkh, k1h, k2h: horizontal wave vector modulus\nkz: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.k1z1p_vs-NTuple{4, Any}","page":"Stratified","title":"WavKinS.k1z1p_vs","text":"k1z1p_vs(kh,kz,k1h,k2h)\n\nk_1z solution of bf k_1 = bf k + bf k_2, omega_1 = omega_bf k + omega_2 (branch +):\n\nk_1z = frack_z2k_h left( k_h + k_1h + k_2h - sqrt (k_h + k_1h + k_2h)^2 - 4 k_h k_1h  right)\n\nkh, k1h, k2h: horizontal wave vector modulus\nkz: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.k1zkm_vs-NTuple{4, Any}","page":"Stratified","title":"WavKinS.k1zkm_vs","text":"k1zkm_vs(kh,kz,k1h,k2h)\n\nk_1z solution of bf k = bf k_1 + bf k_2, omega_bf k = omega_1 + omega_2 (branch -):\n\nk_1z = frack_z2k_h left( k_h - k_1h - k_2h - sqrt (k_h - k_1h - k_2h)^2 + 4 k_h k_1h  right)\n\nkh, k1h, k2h: horizontal wave vector modulus\nkz: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.k1zkp_vs-NTuple{4, Any}","page":"Stratified","title":"WavKinS.k1zkp_vs","text":"k1zkp_vs(kh,kz,k1h,k2h)\n\nk_1z solution of bf k = bf k_1 + bf k_2, omega_bf k = omega_1 + omega_2 (branch +):\n\nk_1z = frack_z2k_h left( k_h + k_1h + k_2h + sqrt (k_h + k_1h + k_2h)^2 - 4 k_h k_1h  right)\n\nkh, k1h, k2h: horizontal wave vector modulus\nkz: vertical wave vector\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.ω_Stratified_Asymp-Tuple{Any, Any}","page":"Stratified","title":"WavKinS.ω_Stratified_Asymp","text":"ω_Stratified_Asymp(kh, kz; N=1.0)\n\nInternal gravity wave frequency in the hydrostatic limit\n\nkh: horizontal wave vector modulus\nkz: vertical wave vector\nN=1.0: buoyancy frequency\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.Stratified_Asymp","page":"Stratified","title":"WavKinS.Stratified_Asymp","text":"Stratified_Asymp\n\nSimulation structure for internal gravity wave turbulence in the hydrostatic limit k_h ll k_z. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum_khkz #wave action\nSk::wave_spectrum_khkz #collisional integral\nF1::wave_spectrum_khkz #working field\nkin_box::kinematic_box #kinematic box: meshes for a (p) and q\nFStp::Vector{Vector{Float64}} #Array of working fields for multithreading\nFStq::Vector{Vector{Float64}} #Array of working fields for multithreading\npartition::Vector{Tuple{UnitRange{Int64},UnitRange{Int64}}} #partition for multithreading\n\n# Type of interpolation, integration, and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ninteg_scheeme::Integ_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\nN::Float64 #buoyancy (Brünt Väisälä) frequency\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Stratified.html#WavKinS.Stratified_Asymp-Tuple{wave_spectrum_khkz}","page":"Stratified","title":"WavKinS.Stratified_Asymp","text":"Stratified_Asymp(Nk::wave_spectrum_khkz; interp_scheeme=bilin_interp_khkz,integ_scheeme=integrate_with_log_bins_khkz,time_stepping_scheeme=RK2_step,Mp=0,Mq=0,nthh=0,nthz=0,N=1.0)\n\nConstructor of a Stratified_Asymp structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme: bilin_interp_khkz (default), cpow_interp_khkz\ninteg_scheeme : integrate_with_log_bins_khkz (default), integrate_with_cpow_khkz\ntime_stepping_scheeme : Euler_step, RK2_step (default), RK4_step\n\nYou can also change:\n\nMp, Mq: number of grid points of the kinematic box in p and q directions\nnthh, nthz: number of slices in k_h and k_z for multithreading\nN=1.0: buoyancy frequency\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.St_k!-Tuple{Stratified_Asymp}","page":"Stratified","title":"WavKinS.St_k!","text":"St_k!(Run::Stratified_Asymp)\n\nCompute collision integral for Stratified_Asymp.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.compute_spectral!-Tuple{Stratified_Asymp}","page":"Stratified","title":"WavKinS.compute_spectral!","text":"compute_spectral(Run)\n\nCompute and store Stratified_Asymp current spectral quantities\n\nRun: StratifiedAsymp WavKinS simulation structure containing the wave action ``n{\\bf k}``\n\nThis routine computes and store in Run.diags.sp_outs the waveaction, energy spectra and their corresponding fluxes.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.store_spectral!-Tuple{Stratified_Asymp}","page":"Stratified","title":"WavKinS.store_spectral!","text":"store_spectral(Run::Stratified_Asymp)\n\nCompute and store Stratified_Asymp spectral quantities\n\nRun: StratifiedAsymp WavKinS simulation structure containing the wave action ``n{\\bf k}``\n\nThis routine computes and store in Run.diags.sp_store  the waveaction, and the energy and waveaction flux spectra.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.compute_ξkz_spectrum-Tuple{Any}","page":"Stratified","title":"WavKinS.compute_ξkz_spectrum","text":"compute_ξkz_spectrum(Run; ρ=one)\n\nCompute (ξ_bf kk_z) spectrum for the quantity with spectral density ρ, where ξ_rm k=k_hk_z^2. It relates to the 3D wave action spectrum n_bf k by s(ξ_bf kk_z) = 2 rho_bf k ξ_bf k k_z^4 mathrmd Omega n_rm k.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.compute_ωkz_spectrum-Tuple{Any}","page":"Stratified","title":"WavKinS.compute_ωkz_spectrum","text":"compute_ωkz_spectrum(Run; ρ=one)\n\nCompute (omega_bf kk_z) spectrum for the quantity with spectral density ρ. It relates to the 3D wave action spectrum n_bf k by s(omega_bf kk_z) = 2 rho_bf k omega_bf k (k_zN)^2 mathrmd Omega n_rm k.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_slices_kzξ_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_slices_kzξ_spectrum!","text":"plot_slices_kzξ_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot slices of the (ξ_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ξkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_slices_kzω_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_slices_kzω_spectrum!","text":"plot_slices_kzω_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot slices of the (ω_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ωkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_slices_ξkz_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_slices_ξkz_spectrum!","text":"plot_slices_ξkz_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot slices of the (ξ_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ξkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_slices_ωkz_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_slices_ωkz_spectrum!","text":"plot_slices_ωkz_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot slices of the (ω_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ωkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_ξkz_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_ξkz_spectrum!","text":"plot_ξkz_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot (ξ_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ξkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_ω_spectrum_density!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_ω_spectrum_density!","text":"plot_ω_spectrum_density!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot frequency spectrum for the quantity with spectral density ρ by integrating the (ω_bf kk_z) spectrum over k_z. See compute_ωkz_spectrum. \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Stratified.html#WavKinS.plot_ωkz_spectrum!-Tuple{Any}","page":"Stratified","title":"WavKinS.plot_ωkz_spectrum!","text":"plot_ωkz_spectrum!(Run; ρ=one, title=\"Quantity spectrum\")\n\nPlot (ω_bf kk_z) spectrum for the quantity with spectral density ρ. See compute_ωkz_spectrum.\n\n\n\n\n\n","category":"method"},{"location":"creating-new-solvers.html#How-to-create-a-new-solver","page":"Creating new solvers","title":"How to create a new solver","text":"","category":"section"},{"location":"creating-new-solvers.html#The-minimal-steps-to-implement-a-new-physical-systems-are","page":"Creating new solvers","title":"The minimal steps to implement a new physical systems are","text":"","category":"section"},{"location":"creating-new-solvers.html","page":"Creating new solvers","title":"Creating new solvers","text":"If none of the structures defined in /src/WavKinS_structures.jl can be used in your problem, create a new one. In this case, most of the routines should probably be adapted.\nCreate a new folder in /src/physical_systems/. It must contain:","category":"page"},{"location":"creating-new-solvers.html","page":"Creating new solvers","title":"Creating new solvers","text":"basics.jl: definitions for your physical system (interaction coefficients, dispersion relation, parameterization of the resonant manifold, etc.).\nstructure.jl: fields and other variables needed for a typical simulation of your new system (diagnostics, working fields, wave-action, etc.).\ncollision_integral.jl: defines the collision integral St_k!(Run).\nspecial.jl: special diagnostics are defined here (optional).  ","category":"page"},{"location":"creating-new-solvers.html","page":"Creating new solvers","title":"Creating new solvers","text":"If you think you're working on something generic (i.e. that can be used for other physical systems), maybe you should write it in different parts of the code (see code structure in index.html). If you're willing to work on a variation of an implemented physical system, you must write it in the same folder (e.g. Acoustic2D and Acoustic3D are both in /src/physical_systems/Acoustic/) for consistency.","category":"page"},{"location":"creating-new-solvers.html#Some-general-advice-for-good-practice","page":"Creating new solvers","title":"Some general advice for good practice","text":"","category":"section"},{"location":"creating-new-solvers.html","page":"Creating new solvers","title":"Creating new solvers","text":"Keep consistent names of fields inside all structures. In doing so, existing routines can be used with your new simulation structures. For example, time-stepping routines in /src/time_stepping/WavKinS_time_steping.jl are generic.\nWrite test files to check what you have implemented for your physical system (parameterization of the resonant manifold, conservation of the dynamical invariant(s) by the collisional integral, ...) in the spirit of /run/tests/physical_systems/tests_Acoustic2D.jl and /run/tests/physical_systems/tests_Petviashvilli.jl.\nIf you have implemented more general tools (integration, interpolation, time stepping, ...), it should also be tested (see, e.g., /run/tests/tests_integration_interpolation.jl and /run/tests/tests_misc.jl) and documented.\nPlease give a short description of your physical system, how you compute the collision integral, and autodocumentation of methods and structures in docs/src/physical_systems/. You should add a link to this documentation in Currently available systems subsection.","category":"page"},{"location":"plots.html#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"We define methods for plots that are wrappers of methods of the Makie.jl package. Many methods have optionnal arguments (e.g. title, xlabel, xscale, ...) consistent with Makie.jl, so please refer to this well documented package for more informations. Wavkins plots allows one to plot standard quantities used in the theory (spectra of different quantities, associated fluxes, global quantities, etc.) quite simply. ","category":"page"},{"location":"plots.html","page":"Plots","title":"Plots","text":"warning: Warning\nIf ones tries to plot a spectrum with negative or zero values in a log-log plot, Makie crashes WavKinS. In the next versions, the plotting routines will be decoupled form the main code and this issue will be solved.","category":"page"},{"location":"plots.html#Basics","page":"Plots","title":"Basics","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/plot/base.jl\"]","category":"page"},{"location":"plots.html#WavKinS.plot_1D_base!-Tuple{Any, Any}","page":"Plots","title":"WavKinS.plot_1D_base!","text":"plot_1D_base!(x, y; fig=nothing, ax=nothing, xlabel=L\"$x$\", ylabel=L\"$y$\", title=\"Title\", xlims=nothing, ylims=nothing, xscale=log10, yscale=log10)\n\nBasic plot of y vs x.\n\nfig: Figure\nax: Axis of the figure\n\nYou can overwrite on a plot by specifying fig and ax. Otherwise, it will create a new plot. Return fig and ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_2D_slices_base!-Tuple{Any, Any, Any}","page":"Plots","title":"WavKinS.plot_2D_slices_base!","text":"plot_2D_slices_base!(x, y, Z; dir=1, nslices=8, fig=nothing, ax=nothing, cb=nothing, slabel=L\"$s$\", zlabel=L\"$z$\", clabel=L\"$c$\", title=\"Title\", slims=nothing, zlims=nothing, clims=nothing, sscale=log10, zscale=log10, cscale=log10, colormap=:inferno)\n\nPlot nslices slices of Z in direction dir.\n\nfig: Figure\nax: Axis of the figure\ncb: Colormap of the figure\n\nYou can overwrite on a plot by specifying fig, ax and cb. Otherwise, it will create a new plot. Return fig, ax and cb.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_heatmap_base!-Tuple{Any, Any, Any}","page":"Plots","title":"WavKinS.plot_heatmap_base!","text":"plot_heatmap_base!(x, y, Z; fig=nothing, ax=nothing, hm=nothing, xlabel=L\"$x$\", ylabel=L\"$y$\", title=\"Title\", xlims=nothing, ylims=nothing, zlims=nothing, xscale=log10, yscale=log10, zscale=log10, colormap=:jet)\n\nBasic heatmap plot of Z vs x and y.\n\nfig: Figure\nax: Axis of the figure\nhm: Colormap of the figure\n\nYou can overwrite on a plot by specifying fig, ax and hm. Otherwise, it will create a new plot. Return fig, ax and hm.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_surface_base!-Tuple{Any, Any, Any}","page":"Plots","title":"WavKinS.plot_surface_base!","text":"plot_surface_base!(x, y, Z; fig=nothing, ax=nothing, hm=nothing, xlabel=L\"$x$\", ylabel=L\"$y$\", zlabel=L\"$z$\", title=\"Title\", xlims=nothing, ylims=nothing, zlims=nothing, xscale=log10, yscale=log10, zscale=log10, colormap=:jet)\n\nBasic surface plot of Z vs x and y.\n\nfig: Figure\nax: Axis of the figure\nhm: Colormap of the figure\n\nYou can overwrite on a plot by specifying fig, ax and hm. Otherwise, it will create a new plot. Return fig, ax and hm.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_theo!-Tuple{Any, Vector{Float64}, Vector{Float64}}","page":"Plots","title":"WavKinS.plot_theo!","text":"plot_theo!(ax, kk::Vector{Float64}, nk::Vector{Float64}; color=\"red\")\n\nAdd the theoretical line nk vs kk on figure with axis ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#Spectra","page":"Plots","title":"Spectra","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/plot/spectra.jl\"]","category":"page"},{"location":"plots.html#WavKinS.plot_1D_spectra_density!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_1D_spectra_density!","text":"function plot_1D_spectra_density!(Run; ρ=one, fig=nothing, ax=nothing, ylabel=L\"$q_k$\", title=\"Quantity 1D spectra\", xlims=nothing, ylims=nothing, xscale=log10, yscale=log10, xcomp = 0.)\n\nPlot k, k_h and k_z spectra of a quantity whose spectral density is ρ. See isotropic_density_spectrum!, kh_density_spectrum! and kz_density_spectrum!.\n\nfig: Figure\nax: Axis of the figure\nxcomp: spectral slope compensation \n\nYou can overwrite on a plot by specifying fig and ax. Otherwise, it will create a new plot. Return fig and ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_2D_slices-Tuple{Any}","page":"Plots","title":"WavKinS.plot_2D_slices","text":"plot_2D_slices(Run; ρ=1, xlims=nothing, ylims=nothing, xscale=log10, yscale=log10, sthks=0:0.2:1)\n\nPlot slices of the spectrum of the quantity with spectral density ρ at constant angles sthks × π/2 with the vertical axis bf e_z. Return the figure fig and its axis ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_2D_slices_khkz!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_2D_slices_khkz!","text":"plot_2D_slices_khkz!(Run; ρ=one, dir=1, nslices=8, fig=nothing, ax=nothing, cb=nothing, zlabel=\"\", title=L\"Spectrum slices\", zlims=nothing, colormap=:inferno)\n\nPlot k_h (dir=1) or k_z (dir=2) slices of the spectrum of the quantity with spectral density ρ. See density_spectrum! and plot_2D_slices_base!.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_density!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_density!","text":"plot_density!(Run; ρ=one, fig=nothing, ax=nothing, hm=nothing, label=L\"$q_k$\", title=\"Quantity spectrum\", xlims=nothing, ylims=nothing, zlims=nothing, xscale=log10, yscale=log10, zscale=log10, xcomp = 0.)\n\nPlot spectrum of a quantity whose spectral density is ρ. See density_spectrum!.\n\nfig: Figure\nax: Axis of the figure\nhm: Colormap of the figure\nxcomp: spectral slope compensation \n\nYou can overwrite on a plot by specifying fig, ax and hm. Otherwise, it will create a new plot. Return fig, ax and hm.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_energy!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_energy!","text":"function plot_energy!(Run; fig=nothing, ax=nothing, hm=nothing, xlims=nothing, ylims=nothing, zlims=nothing, xscale=log10, yscale=log10, zscale=log10, xcomp = 0.)\n\nPlot energy spectrum. It is plot_density! with ρ=ω.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_wave_action!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_wave_action!","text":"function plot_wave_action!(Run; fig=nothing, ax=nothing, hm=nothing, xlims=nothing, ylims=nothing, zlims=nothing, xscale=log10, yscale=log10, zscale=log10, xcomp = 0.)\n\nPlot wave action spectrum. It is plot_density! with ρ=1.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#Fluxes","page":"Plots","title":"Fluxes","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/plot/fluxes.jl\"]","category":"page"},{"location":"plots.html#WavKinS.plot_2D_flux-Tuple{wave_spectrum_khkz, Matrix{Float64}, Matrix{Float64}}","page":"Plots","title":"WavKinS.plot_2D_flux","text":"plot_2D_flux(Nk::wave_spectrum_khkz, Fh::Matrix{Float64}, Fz::Matrix{Float64}; xlabel=L\"$log_{10} k_h$\", ylabel=L\"$log_{10} k_z$\", title=\"Fluxes\")\n\nPlot fluxes for anisotropic systems.\n\nNk: structure containing the grid\nFh: flux in horizontal wave vectors \nFz: flux in vertical wave vectors\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_density_flux!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_density_flux!","text":"plot_density_flux!(Run; ρ=one, fig=nothing, ax=nothing, label=L\"$P_k$\", title=\"Density flux\", Disp = 1., xlims=nothing, ylims=nothing)\n\nPlot fluxes of a quantity whose spectral density is ρ. See density_flux! and plot_2D_flux.\n\nfig: Figure\nax: Axis of the figure\n\nYou can overwrite on a plot by specifying fig and ax. Otherwise, it will create a new plot. Return fig and ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_density_flux_angular!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_density_flux_angular!","text":"plot_density_flux_angular!(Run; ρ=one, fig=nothing, ax=nothing, label=L\"$P_k$\", title=\"Angular quantity flux\", Disp = 1., xlims=nothing, ylims=nothing, xscale=identity, yscale=identity)\n\nPlot the angular fluxes of a quantity whose spectral density is ρ. See density_flux_angular!.\n\nfig: Figure\nax: Axis of the figure\n\nYou can overwrite on a plot by specifying fig and ax. Otherwise, it will create a new plot. Return fig and ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_density_flux_isotropic!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_density_flux_isotropic!","text":"plot_density_flux_isotropic!(Run; ρ=one, fig=nothing, ax=nothing, label=L\"$P_k$\", title=\"Isotropic quantity flux\", Disp=1., xlims=nothing, ylims=nothing, xscale=log10, yscale=identity)\n\nPlot the isotropic (after sum over angle) fluxes of a quantity whose spectral density is ρ. Corresponds to the standard flux for isotropic systems. See density_flux_isotropic!.\n\nfig: Figure\nax: Axis of the figure\n\nYou can overwrite on a plot by specifying fig and ax. Otherwise, it will create a new plot. Return fig and ax.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_energy_flux!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_energy_flux!","text":"plot_energy_flux!(Run; fig=nothing, ax=nothing, Disp = 1., xlims=nothing, ylims=nothing)\n\nPlot energy fluxes. It is plot_density_flux! with ρ=ω.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_energy_flux_angular!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_energy_flux_angular!","text":"plot_energy_flux_angular!(Run; fig=nothing, ax=nothing, Disp = 1., xlims=nothing, ylims=nothing, xscale=identity, yscale=identity)\n\nPlot the angular fluxes of energy. It is plot_density_flux_angular! with ρ=ω.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_energy_flux_isotropic!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_energy_flux_isotropic!","text":"plot_energy_flux_isotropic!(Run; fig=nothing, ax=nothing, Disp=1., xlims=nothing, ylims=nothing, xscale=log10, yscale=identity)\n\nPlot the isotropic (after sum over angle) energy fluxes. It is plot_density_flux_isotropic! with ρ=ω.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_wave_action_flux!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_wave_action_flux!","text":"plot_wave_action_flux!(Run; fig=nothing, ax=nothing, Disp = 1., xlims=nothing, ylims=nothing)\n\nPlot wave action fluxes. It is plot_density_flux! with ρ=1.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_wave_action_flux_angular!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_wave_action_flux_angular!","text":"plot_wave_action_flux_angular!(Run; fig=nothing, ax=nothing, Disp = 1., xlims=nothing, ylims=nothing, xscale=identity, yscale=identity)\n\nPlot the angular fluxes of wave action. It is plot_density_flux_angular! with ρ=1.\n\n\n\n\n\n","category":"method"},{"location":"plots.html#WavKinS.plot_wave_action_flux_isotropic!-Tuple{Any}","page":"Plots","title":"WavKinS.plot_wave_action_flux_isotropic!","text":"plot_wave_action_flux_isotropic!(Run; fig=nothing, ax=nothing, Disp=1., xlims=nothing, ylims=nothing, xscale=log10, yscale=identity)\n\nPlot the isotropic (after sum over angle) wave action fluxes. It is plot_density_flux_isotropic! with ρ=1.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/generalities.html#Physical-systems","page":"Generalities","title":"Physical systems","text":"","category":"section"},{"location":"physical_systems/generalities.html","page":"Generalities","title":"Generalities","text":"Here we define the solvers of the physical systems.","category":"page"},{"location":"physical_systems/generalities.html#Generalities","page":"Generalities","title":"Generalities","text":"","category":"section"},{"location":"physical_systems/generalities.html","page":"Generalities","title":"Generalities","text":"Methods that are common to several solvers.","category":"page"},{"location":"physical_systems/generalities.html","page":"Generalities","title":"Generalities","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/basics_all.jl\"]","category":"page"},{"location":"physical_systems/generalities.html#WavKinS.Delta-Tuple{Float64, Float64, Float64}","page":"Generalities","title":"WavKinS.Delta","text":"Delta(k::Float64, k1::Float64, k2::Float64)\n\nAssuming that k_1  k + k_2, k_2  k + k_1, and k  k_1 + k_2, it returns twice the area of the triangle of sides k, k_1, and k_2, i.e. Delta = frac12 sqrt(k + k_1 + k_2) (k + k_1 - k_2) (k - k_1 + k_2) (-k + k_1 + k_2) = 2 left (k k_1)^2 + (k k_2)^2 + (k_1 k_2)^2 right - k^4 - k_1^4 - k_2^4. \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/generalities.html#WavKinS.Δ_vs-Tuple{Float64, Float64, Float64}","page":"Generalities","title":"WavKinS.Δ_vs","text":"Δ_vs(k::Float64, p::Float64, q::Float64)\n\nReturn Delta = frac12 sqrt(k^2-p^2) q (2 k+q). It is Delta with k_1 = (k + p + q)2 and k_2 = (k - p + q)2.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/generalities.html#WavKinS.θkmax-Tuple{Any, Any}","page":"Generalities","title":"WavKinS.θkmax","text":"θkmax(k,kmax)\n\nGives ones if k  k_max, 0, otherwise. \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/TestTimeStepping.html#TestTimeStepping-solver","page":"TestTimeStepping","title":"TestTimeStepping solver","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html#Description","page":"TestTimeStepping","title":"Description","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"System used to check Time-stepping methods accuracy. In this case, the collision integral is","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"St_bf k = n_bf k^2","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"so the kinetic equation has non trivial, but analytical solutions.","category":"page"},{"location":"physical_systems/TestTimeStepping.html#Solver","page":"TestTimeStepping","title":"Solver","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"There is no coupling between different modes, so the implementation of the solver is straigthforward.","category":"page"},{"location":"physical_systems/TestTimeStepping.html#Diagnostics","page":"TestTimeStepping","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"The standard diagnostics should work for this system.","category":"page"},{"location":"physical_systems/TestTimeStepping.html#Theoretical-predictions","page":"TestTimeStepping","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"The analytical solution for the wave action is ","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"n_bf k(t) = frac12 left( d_bf k + c_bf k tan left( arctan left( frac-d_bf k + 2 n_bf k(0)c_bf k right) + fracc_bf k t2 right) right)","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"where c_bf k = sqrt4 f_bf k - d_bf k^2 . The numerical prediction is compared to the analytical solution for different time-stepping methods in the run/tests/tests_time_stepping.jl script. It allows to check that the Runge-Kutta 2 RK2_step method is of order 2 accurary with the time step mathrmdt, as shown on the following figure","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"(Image: )","category":"page"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"The other methods (e.g. Euler_step or RK4_step) can be tested as well.","category":"page"},{"location":"physical_systems/TestTimeStepping.html#List-of-structures-and-methods-for-TestTimeStepping-solver","page":"TestTimeStepping","title":"List of structures and methods for TestTimeStepping solver","text":"","category":"section"},{"location":"physical_systems/TestTimeStepping.html","page":"TestTimeStepping","title":"TestTimeStepping","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/TestTimeStepping/basics.jl\", \"src/physical_systems/TestTimeStepping/structure.jl\", \"src/physical_systems/TestTimeStepping/collision_integral.jl\"]","category":"page"},{"location":"physical_systems/TestTimeStepping.html#WavKinS.TestTimeStepping","page":"TestTimeStepping","title":"WavKinS.TestTimeStepping","text":"TestTimeStepping\n\nSimulation structure for TestTimeStepping system. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\n\nNk::wave_spectrum # wave action\nSk::wave_spectrum # collisional integral\nF1::wave_spectrum # working field\npartition::Vector{UnitRange{Int64}} # partition for multithreading\n\ntime_stepping::Time_Stepping\n\nt::Float64 # current time\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/TestTimeStepping.html#WavKinS.TestTimeStepping-Tuple{wave_spectrum}","page":"TestTimeStepping","title":"WavKinS.TestTimeStepping","text":"TestTimeStepping(Nk::wave_spectrum; time_stepping_scheeme=RK2_step)\n\nConstructor of a TestTimeStepping structure. \n\nNk: wave spectrum structure\ntime_stepping_scheeme: Euler_step, RK2_step (default), ETD2_step, ...\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/TestTimeStepping.html#WavKinS.St_k!-Tuple{TestTimeStepping}","page":"TestTimeStepping","title":"WavKinS.St_k!","text":"St_k!(Run::TestTimeStepping)\n\nCompute collision integral for TestTimeStepping.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/MMT.html#MMT-solver","page":"MMT","title":"MMT solver","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The Majda-McLaughlin-Tabak (MMT) Majda et al., J. Nonliear Science. Vol. 7, 9–44, (1997) model was introduced by the authors as a simple and numerically affordable model to test the theory of wave turbulence. It consists on one-dimensional partial differential equation where the dispersion relation and the homogeneity degree of the non-linearity are tunable parameters. This model has triggered enormous research and opened the way to the study of solitonic turbulence. It is still the matter of recent academic research. For a complete review see Zakharov et al., Physics Report. Vol. 398, Issue 1, (2004).","category":"page"},{"location":"physical_systems/MMT.html#Description","page":"MMT","title":"Description","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"In the solver, we consider the WKE of the 1D-MMT model dotn_k=St_k that explicitly reads","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"\ndotn_k=4pi intleft T^k1_23right^2delta(k+k_1-k_2-k_3)delta(omega^k1_23)n_kn_1n_2n_3left(frac1n_k+frac1n_1-frac1n_2-frac1n_3   right)dk_1dk_2dk_3 ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"where omega^k1_23=omega_k+omega_1-omega_2-omega_3. More explicitly, for the  MMT model we have","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"    omega_k=k^alpha quad T^k1_23=k k_1 k_2 k_3^beta4","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The solver only consider the case α=1/2 for which we can provide an analytical paremetrisation of the resonant manifold (given below)","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"k+k_1-k_2-k_3 = 0quad\nomega_k+omega_1-omega_2-omega_3 = 0","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"This wave kinetic equation conserves the total energy H and waveaction N","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"N= int_-infty^infty n_kdk quad rm and quad H = int_-infty^infty omega_k n_kdk","category":"page"},{"location":"physical_systems/MMT.html#Solver","page":"MMT","title":"Solver","text":"","category":"section"},{"location":"physical_systems/MMT.html#The-reduced-truncated-MMT-wave-kinetic-equation","page":"MMT","title":"The reduced truncated MMT wave kinetic equation","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"WavKinS solves the MMT wave kinetic equation making use of the two δ-Dirac. More precisely, it solves the following kinetic equation","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"dotn_k=4pi int_-infty^inftyfracleft tildeT^k1_23right^2Delta_12n_kn_1n_2n_3left(frac1n_k+frac1n_1-frac1n_2-frac1n_3   right)dk_3","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"where Delta_12=frac12left fracsign(k_2)sqrtk_2- fracsign(k_1)sqrtk_1  right, k_2=k+k_1(k_3)-k_3 and k_1(k_3)=k q_1(frack_3k), with","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"q_1(q_3) = left\n        beginarrayll\n            -fracleft(q_3+sqrt-q_3-1right)^2left(sqrt-q_3-1right)^2  quad q_3 leq -1 \n            fracq_3 left(q_3-2 sqrt-q_3-1right)(q_3+1)^2  quad -1 leq q_3 leq 0\n            frac12 left(sqrt8 q_3^32-3 q_3^2-6 q_3+1+q_3-1right)  quad 0 leq q_3 leq 1\n            frac12 left(sqrtq_3^2-6 q_3+8 sqrtq_3-3+q_3-1right)  quad 1 leq q_3\n        endarray\n    right","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The modified collisional matrix is simply tildeT^k1_23=theta_ktheta_1theta_2theta_3 tildeT^k1_23, where theta_k = 1 if kle k_rm max, and 0 otherwise, with k_rm max the maximum wavenumber. This truncated WKE, exactly conserves the truncated invariants ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"N= int_kk_rm max n_kdk quad rm and quad H = int_kk_rm max omega_k n_kdk","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"We use logarithmic grid wave_spectrum to represent the waveaction spectrum n_k. The integral in the collisional is computed first for k_30, assuming n_k=n_-k, and then for k0. There are no singular terms to take care of. ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Note the if we use M nodes to simulate the MMT model, then the numerical cost is of the order of M^2 operations.","category":"page"},{"location":"physical_systems/MMT.html#Using-the-MMT-solver","page":"MMT","title":"Using the MMT solver","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"As all the other WavKinS solvers, for MMT we need to create a MMT structure containing all the fields, working space, diagnostics, etc.  ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"using WavKinS\n\n# Create a waveaction structure containing the basic grid\nM = 256 # set the number of nodes\nkmin = 1e-6 # minimal wave number\nkmax = 1e0 # maximal wave number\nNk = wave_spectrum(kmin,kmax,M)\n\n# Creating a MMT run structure with default parameters and β = 0.\nRun = MMT(Nk; β=0.0);","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The MMT solver has implemented an option to compute the collisional term as a sink and a source term","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"St_bf k = -gamma_bf k n_bf k + eta_bf k","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The computation of γ and η are performed with the options compute_γk and compute_ηk and accesible as:    ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"# computing collisional integral\nSt_k!(Run;compute_Sk=true, compute_γk=true, compute_ηk=true)\nγ_k = Run.γk\nη_k = Run.ηk    ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"If both, compute_γk=false and compute_ηk=false, then St_k is computed directly.","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"warning: Warning\nThe MMT solver is compatible with the time stepping AB_Euler_step and AB2_RK2_step, but still under testing. ","category":"page"},{"location":"physical_systems/MMT.html#Diagnostics","page":"MMT","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"In addition to the standard diagnostics, the solver computes the waveaction flux spectrum.","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Q_k = -2int_0^k St_q dq","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Spectral and global quantities can be directly computed using the provided routines (see  this tutorial). It is stored in ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"  Run.diags.sp_outs[\"Qk\"] # for I/0 purposes\n  Run.diags.sp_store[\"Qk\"] # stored over time","category":"page"},{"location":"physical_systems/MMT.html#Testing-convergence-of-the-collisional-integral","page":"MMT","title":"Testing convergence of the collisional integral","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"WavKinS provide a simple test of the numerical convergence of the computation of the collisional integral. The testing script is located in /run/tests/physical_systems/tests_MMT.jl. ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Theoretically, the collisional integral should conserve the waveaction and the energy, which means that","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"int_-infty^infty St_k dk=0 quad int_-infty^infty omega_k St_k dk=0","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The following numerical test evaluates those integrals and check the convergence to 0.","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"using WavKinS\n\nfunction nk_test(kx)\n    return exp(-abs(kx)) * kx^2\nend\n\nfor M ∈ 2 .^ (4:10)\n    kmin = 1e-3\n    kmax = 1e+2\n\n    Nk = wave_spectrum(kmin,kmax,M)\n    Run = WavKinS.MMT(Nk; interp_scheeme=WavKinS.lin_interp);\n\n    kk = Nk.kk\n    @. Nk.nk = nk_test.(kk)\n\n    WavKinS.St_k!(Run;compute_Sk=true, compute_γk=true, compute_ηk=true)\n    \n    Flux = wave_spectrum(kmin,kmax,M)\n    @. Flux.nk =  Run.Sk.nk\n    NFlux= integrate_with_log_bins(Flux)\n    \n    @. Flux.nk = Run.ω(kk) * Run.Sk.nk\n    EFlux= integrate_with_log_bins(Flux)\n\n    AA = total_waveaction(Run)\n    Ene = energy(Run)\n\n    println(\"M = \", M, \", Integral flux num: dN/N=\", NFlux/AA, \" dH/H=\", EFlux/Ene)\n\nend","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The output of this test is ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"M = 16, Integral flux num: dN/N=-3.067434124891184e-11 dH/H=1.5573442892100724\nM = 32, Integral flux num: dN/N=-2.395977091429804e-11 dH/H=0.1108223756248543\nM = 64, Integral flux num: dN/N=-2.069127127113921e-11 dH/H=0.03449846831998508\nM = 128, Integral flux num: dN/N=3.257316662210291e-10 dH/H=0.007241206687316066\nM = 256, Integral flux num: dN/N=6.161729620725928e-8 dH/H=0.0019066862575089908\nM = 512, Integral flux num: dN/N=1.2749063308649134e-9 dH/H=0.000501465301534334\nM = 1024, Integral flux num: dN/N=-2.3447541840433413e-10 dH/H=0.0001278778185124224","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The solver conserves well the waveaction and errors on energy conservation roughly decreases as M^-2.","category":"page"},{"location":"physical_systems/MMT.html#Theoretical-predictions","page":"MMT","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"As usual in wave turbulence theory, there is a number of theoretical predictions for the MMT model. In the case of out-of-equilibrium solutions, with forcing and dissipation, the theoretical predictions are ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"n_k=C_KZ^Q Q_0^13k^-x_Qquad n_k=C_KZ^P P_0^13k^-x_P","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"where Q_0 and P_0 are the waveaction and energy fluxes, and the superscript Q and P denotes the inverse waveaction and direct energy cascades, respectively. The theory predicts Zakharov et al., Physics Report. Vol. 398, Issue 1, (2004) ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"x_Q =1+( 2beta-alpha)3  quad x_P=1+2beta3","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"The constants C_KZ^Q=(3(8pi I(x_Q)))^13 and C_KZ^P=(3(8pi I(x_P)))^13, with I(x) the dimensionless collisional integral, can be also computed numerically. WavKinS also provides routines to compute the derivatives of I(x) with alpha=12. They can be accessed as","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"β = Run.β;\nα = 1.0 / 2.0;\nxQ = 2 * β / 3 + 1 - α / 3;\nxP = 2 * β / 3 + 1;\nWavKinS.dxI_MMT(xP)\nWavKinS.dxI_MMT(xQ)","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"which produces the output ","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"-2.354496680354443\n6.061632815153047","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Note that I(x_Q)0 and I(x_P)0, consistently with the expected inverse and direct cascade for waveaction and energy, respectively.","category":"page"},{"location":"physical_systems/MMT.html#Running-the-MMT-solver","page":"MMT","title":"Running the MMT solver","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"WavKinS provides a ready to use script to obtain out-of-equilibrium steady states of the WKE. The script is similar to the one presented in the tutorial and can be found in /run/simple/RunSimpleEvolution_MMT.jl. Running the script will generate the following plot","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"(Image: ) The dashed lines are the theoretical predictions for the inverse waveaction (green) and direct energy (blue) cascades, with no adjustable parameters.","category":"page"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"info: Info\nThe previous plot took less than 30 seconds on a 3 GHz 10-Core Intel Xeon W iMac Pro, using 4 cores. ","category":"page"},{"location":"physical_systems/MMT.html#List-of-structures-and-methods-for-MMT-solver","page":"MMT","title":"List of structures and methods for MMT solver","text":"","category":"section"},{"location":"physical_systems/MMT.html","page":"MMT","title":"MMT","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/MMT/basics.jl\", \"src/physical_systems/MMT/structure.jl\", \"src/physical_systems/MMT/collision_integral.jl\",\"src/physical_systems/MMT/diagnostics.jl\"]","category":"page"},{"location":"physical_systems/MMT.html#WavKinS.dxI_MMT-Tuple{Any}","page":"MMT","title":"WavKinS.dxI_MMT","text":"dxI_MMT(x; β=0.0, kmax=10000, npoints=100000)\n\nCompute the derivative of the dimensionless colissional integral for the MMT model\n\nx: value of the exponent (argument of the funcion)\nβ : homogeneity degree of the interaction matrix. (default β=0) \nkmax : Ultraviolet cut off. (default kmax=10000) \nnpoints : number of discretisation points. (default npoints=100000) \n\n\n\n\n\n","category":"method"},{"location":"physical_systems/MMT.html#WavKinS.MMT","page":"MMT","title":"WavKinS.MMT","text":"MMT\n\nSimulation structure for MMT wave turbulence. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``.  1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nγk::Vector{Float64} # gamma term of WKE\nηk::Vector{Float64} # eta term of WKE\n\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt1::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt2::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\nβ::Float64 # dispersive length\ndimension::Int # physical dimension of the system\ndΩ::Float64 # surface of the unit sphere\n\nFD::force_dissipation # Contains all the terms about force and dissipation\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/MMT.html#WavKinS.MMT-Tuple{wave_spectrum}","page":"MMT","title":"WavKinS.MMT","text":"MMT(Nk::wave_spectrum; β=0.,interp_scheeme=lin_interp,drive_scheeme=RK2_step\n\nConstructor of a MMT structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme : lin_interp (default), powexp_interp, powGauss_interp,BS_interp\ndrive_scheeme : Euler_step, RK2_step (default), ETD2_step, AB_Euler_step, and AB2_RK2_step.\n\nThe parameter β=0. is the exponent of non-linear term\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/MMT.html#WavKinS.compute_spectral!-Tuple{MMT}","page":"MMT","title":"WavKinS.compute_spectral!","text":"compute_spectral(Run)\n\nCompute and store MMT current spectral quantities\n\nRun: MMT WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_outs the waveaction, energy spectra and their corresponding fluxes.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/MMT.html#WavKinS.store_spectral!-Tuple{MMT}","page":"MMT","title":"WavKinS.store_spectral!","text":"store_spectral(Run::MMT)\n\nCompute and store MMT spectral quantities\n\nRun: MMT WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_store  the waveaction, and the energy and waveaction flux spectra.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/diagnostics_tutorial.html#Defining-a-new-diagnostic","page":"Adding a diagnostic","title":"Defining a new diagnostic","text":"","category":"section"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"Suppose that you would like to run WavKinS and compute a new diagnostic that has not been included in the original physical system. You would like also that WavKinS writes to the disk this new measurement together the default ones. ","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"In this tutorial, we assume that you know how to define the basic WavKinS structures. We now explain how to add a new diagnostic computed from the waveaction n_bf k.","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"note: Note\nBefore running any of the commands below you need to indicate to Julia the path to the folder where WavKinS has been installed, here denoted as PATH_TO_WAVKINS_FOLDER. In Linux bash, this is set by setting the JULIA_LOAD_PATH environment variableexport JULIA_LOAD_PATH=\"PATH_TO_WAVKINS_FOLDER:$JULIA_LOAD_PATH\" ","category":"page"},{"location":"quick_start/diagnostics_tutorial.html#Basic-structures-for-diagnostic","page":"Adding a diagnostic","title":"Basic structures for diagnostic","text":"","category":"section"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"For simplicity, in this tutorial we also consider the Acoustic2D physical system. As in the previous tutorial, we initialise the waveaction and Acoustic2D structures and fill the wave action with something not trivial (the Rayleigh–Jeans distribution). ","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"using WavKinS\nM = 1024\nkmin = 1e-3\nkmax = 1e0\nNk = wave_spectrum(kmin, kmax, M)\n\nRun = Acoustic2D(Nk)\n\nkk = Run.Nk.kk # we rename the wavevector mesh for shorter use\nnk = Run.Nk.nk # we rename the waveaction mesh for shorter use\n@. nk = 1.  / Run.ω(kk) # the @. is the julia macro for pointwise operations","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"The default diagnostics are stored in Run, and initially empty or set to zeroes. They are stored as a dictionary of WavKinS.global_ouput and WavKinS.spectral_output (follow links for a precise definition):","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> Run.diags.glob_diag\nDict{String, WavKinS.global_ouput} with 4 entries:\n  \"N\"     => global_ouput(\"Total wave action\", Float64[])\n  \"Times\" => global_ouput(\"Times of global quantities\", Float64[])\n  \"H\"     => global_ouput(\"Total energy\", Float64[])\n  \"Disp\"  => global_ouput(\"Total dissipation\", Float64[])","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"and","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> Run.diags.sp_outs\nDict{String, WavKinS.spectral_output} with 3 entries:\n  \"nk\" => spectral_output(\"Wave action spectrum\", [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], true)\n  \"Ek\" => spectral_output(\"Energy spectrum\", [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], true)\n  \"Pk\" => spectral_output(\"Energy flux\", [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], true)","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"We want to add two new diagnostics, for instance a global quantity B and a spectral one B_k","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"B= int rho_k n_k dbf k quad   B_k=rho_k n_k","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"where rho_k is some density function of k only. Note that the invariant B is computed over all the Fourier space. For the Acoustic2D, dbf k can be replaced by 2pi dk.","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"Let us first to create a place where to store these two diagnostics using the constructors of the diagnostic and the flexibility of the dictionary","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"Run.diags.glob_diag[\"B\"]= WavKinS.global_ouput(\"My new global diagnostic\")\nRun.diags.sp_outs[\"Bk\"] = WavKinS.spectral_output(\"My new spectral diagnostic\",Nk.M)","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"For instance, WavKinS.global_ouput contains now","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> Run.diags.glob_diag\nDict{String, WavKinS.global_ouput} with 5 entries:\n  \"B\"     => global_ouput(\"My new global diagnostic\", Float64[])\n  \"N\"     => global_ouput(\"Total wave action\", Float64[])\n  \"Times\" => global_ouput(\"Times of global quantities\", Float64[])\n  \"H\"     => global_ouput(\"Total energy\", Float64[])\n  \"Disp\"  => global_ouput(\"Total dissipation\", Float64[])","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"We see now that B is included in the global diagnostics.","category":"page"},{"location":"quick_start/diagnostics_tutorial.html#Computing-the-new-diagnostic","page":"Adding a diagnostic","title":"Computing the new diagnostic","text":"","category":"section"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"Let's first define the density rho_k that we will use for the diagnostics (an arbitrary function of k)","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"function ρk(k)\n    return k^4 /(1 + k^2)\nend","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"We are now going to compute the default and the new diagnostics. First we call the WavKinS routines for the default diagnostics","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"get_global_diagnostics!(Run)\ncompute_spectral!(Run)","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"Finally, we compute the new diagnostics and add them to diagnostics","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"# For the global diagnostic\nB = WavKinS.total_integral_density(Run, ρk) # we use WavKinS routine to compute B\npush!(Run.diags.glob_diag[\"B\"].out, B) # we append it to the diagnostic\n\n# For the spectral diagnostic\nBk = Run.diags.sp_outs[\"Bk\"].sp;\nnk = Run.Nk.nk;\nkk = Run.Nk.kk;\n@. Bk = ρk(kk) * nk;  ","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"The diagnostics have now","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> Run.diags.glob_diag\nDict{String, WavKinS.global_ouput} with 5 entries:\n  \"B\"     => global_ouput(\"My new global diagnostic\", [0.74606])\n  \"N\"     => global_ouput(\"Total wave action\", [6.28321])\n  \"Times\" => global_ouput(\"Times of global quantities\", [0.0])\n  \"H\"     => global_ouput(\"Total energy\", [3.14164])\n  \"Disp\"  => global_ouput(\"Total dissipation\", [0.0])","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"and","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> Run.diags.sp_outs\nDict{String, WavKinS.spectral_output} with 4 entries:\n  \"nk\" => spectral_output(\"Wave action spectrum\", [1000.0, 993.27, 986.586, 979.946, 973.352, 966.801, 960.295, 953.833, 947.414, 941.038  …  1.06266, 1.05551, 1.0484, 1.04135, 1.03434, 1.02738, 1.02046, 1.0136, 1.00678, 1.0], true)\n  \"Ek\" => spectral_output(\"Energy spectrum\", [0.00628319, 0.00632576, 0.00636861, 0.00641176, 0.00645521, 0.00649894, 0.00654297, 0.0065873, 0.00663194, 0.00667687  …  5.91271, 5.95277, 5.99311, 6.03371, 6.07459, 6.11575, 6.15719, 6.1989, 6.24…\n  \"Pk\" => spectral_output(\"Energy flux\", [3.47654e-11, 3.5239e-11, 3.57211e-11, 3.62117e-11, 3.6711e-11, 3.7219e-11, 3.77361e-11, 3.82622e-11, 3.87975e-11, 3.93423e-11  …  -9.75031e-7, -1.16121e-6, -1.35282e-6, -1.54999e-6, -1.75284e-6, -1.961…\n  \"Bk\" => spectral_output(\"My new spectral diagnostic\", [9.99999e-10, 1.02046e-9, 1.04135e-9, 1.06266e-9, 1.0844e-9, 1.10659e-9, 1.12924e-9, 1.15235e-9, 1.17593e-9, 1.19999e-9  …  0.44196, 0.448142, 0.454391, 0.460705, 0.467086, 0.473534, 0.48…","category":"page"},{"location":"quick_start/diagnostics_tutorial.html#Writing-the-diagnostic-into-a-file","page":"Adding a diagnostic","title":"Writing the diagnostic into a file","text":"","category":"section"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"WavKinS uses the NCDF format using the NCDataset Julia Package to mange the I/O. Once the new diagnostics are created and stored in WavKinS.global_ouput and WavKinS.spectral_output they will be written automatically whenever the routines output_spectra and output_global are called.","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"To create the output we do the following","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"outputDir = \"./\"\ninit_IO(Run, outputDir) # Create an empty NCDF file\noutput_global(Run, outputDir) \noutput_spectra(Run, outputDir)","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"After calling these routines, a file called in this case WKE_Acoustic2D_data.nc will created and written in outputDir. The name of the file depends on the solver used. To list the content of the file, we can simple make","category":"page"},{"location":"quick_start/diagnostics_tutorial.html","page":"Adding a diagnostic","title":"Adding a diagnostic","text":"julia> using NCDataset\njulia> file=NCDataset(outputDir * \"WKE_\" * Run.name * \"_data.nc\")\nDataset: WKE_Acoustic2D_data.nc\nGroup: /\n\nDimensions\n   k = 1024\n   timesSP = 1\n   times = 1\n\nGlobal attributes\n  Dataset              = Acoustic2D\n  Created with git commit id = unknown\nGroups\n  Dataset: WKE_Acoustic2D_data.nc\n  Group: Global\n\n  Variables\n    B     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  times\n      Attributes:\n       long_name            = My new global diagnostic\n\n    N     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  times\n      Attributes:\n       long_name            = Total wave action\n\n    Times     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  times\n      Attributes:\n       long_name            = Times of global quantities\n\n    H     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  times\n      Attributes:\n       long_name            = Total energy\n\n    Disp     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  times\n      Attributes:\n       long_name            = Total dissipation\n\n  Dataset: WKE_Acoustic2D_data.nc\n  Group: Spectral\n\n  Variables\n    k     (1024)\n      Datatype:    Float64 (Float64)\n      Dimensions:  k\n      Attributes:\n       long_name            = wave vectors\n\n    TimesSP     (1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  timesSP\n      Attributes:\n       long_name            = Times of spectral outputs\n\n    nk     (1024 × 1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  k × timesSP\n      Attributes:\n       long_name            = Wave action spectrum\n\n    Ek     (1024 × 1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  k × timesSP\n      Attributes:\n       long_name            = Energy spectrum\n\n    Pk     (1024 × 1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  k × timesSP\n      Attributes:\n       long_name            = Energy flux\n\n    Bk     (1024 × 1)\n      Datatype:    Float64 (Float64)\n      Dimensions:  k × timesSP\n      Attributes:\n       long_name            = My new spectral diagnostic\n\n\n\njulia> close(file)\nclosed Dataset","category":"page"},{"location":"physical_systems/Petviashvilli.html#Petviashvilli_Asympsolver","page":"Petviashvilli","title":"Petviashvilli_Asympsolver","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The Petviashvilli equation is an important model describing geophysical flows and fusion plasmas. In particular, it models drift waves in plasmas and Rossby waves in geophysical fluids. For a theoretical application of the WWT to this model, see Nazarenko, Springer, Volume 825 of Lecture Notes in Physics (2011), where the Petviashvilli equation is used as a master example to introduce the theory.","category":"page"},{"location":"physical_systems/Petviashvilli.html#Description","page":"Petviashvilli","title":"Description","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"In the solver, we consider the asymptotic Petviashvilli WKE dotn_bf k=St_bf k that explicitly reads","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"St_bf k=int (mathcalR^bf k_12-mathcalR^1_2 bf k-mathcalR^2_bf k1)mathrmdbf k_1mathrmdbf k_2","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"with mathcalR^bf k_12=2piV_bf k12^2(n_1n_2-n_1n_bf k-n_bf kn_2)delta(bf k-bf k_1-bf k_2)delta(omega_bf k- omega_1- omega_2) and bf k=(k_xk_y), with k_x0. In particular, we consider the asymptotic limit k_xll k_y, for which the interaction coefficient and dispersion relation are","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"omega_bf k= k_x k_y^2quad V_bf 123=frac12sqrtk_1xk_2xk_3x","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"This wave kinetic equation conserves the total energy H, the potential vorticity Omega and the zonostrophy Phi","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"H = int_k_x0 omega_bf k n_bf k dbf kquad Omega = int_k_x0 k_x n_bf k dbf kquad Phi= int_k_x0 frack_x^3k_y^2 n_bf k dbf kquad","category":"page"},{"location":"physical_systems/Petviashvilli.html#Solver","page":"Petviashvilli","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html#The-reduced-asymptotic-Petviashvilli-WKE-wave-kinetic-equation","page":"Petviashvilli","title":"The reduced asymptotic Petviashvilli WKE wave kinetic equation","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"WavKinS solves the asymptotic Petviashvilli wave kinetic equation making use of the δ-Dirac's. More precisely, it solves the following kinetic equation","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"dotn_bf k=St_bf k =I_bf k-2J_bf k","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"where","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"I_bf k=int_-k_y^0  fracmathcalR^bf k_bf 12Delta_k_y k_1y dk_1y + int_k_y^2k_y   fracmathcalR^bf k_bf 12Delta_k_y k_1y dk_1y","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"with bf k_2=bf k-bf k_1, and","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"k_1x=k_xfrack_1y(2k_y-k_1y)k_y(2k_1y - k_y)quad Delta_k_y k_1y = k_y(2k_1y-k_y)","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Similarly, the second term is ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"J_bf k=int_-infty^-k_y  fracmathcalR^bf 1_bf k2Delta_k_y k_1y dk_1y + int_frack_y2^k_y   fracmathcalR^bf 1_bf k2Delta_k_y k_1y dk_1y","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"with bf k_2=bf k_1-bf k and k_1x and Delta_k_y k_1y as above. There are not strong divergences in the integrand.","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"In the integration, we assume n_k_x-k_y=n_k_xk_y and the integral is truncated at k_rm maxy. The truncated WKE, exactly conserves the truncated invariants. We use the logarithmic two-dimensional grid wave_spectrum_khkz to represent the waveaction spectrum n_bf k. ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Note the if we use M nodes to represent each coordinate of the Fourier space, then, the numerical cost of computing the collisional integral is of the order of M^3 operations.","category":"page"},{"location":"physical_systems/Petviashvilli.html#Using-the-Petviashvilli_Asymp-solver","page":"Petviashvilli","title":"Using the Petviashvilli_Asymp solver","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"As all the other WavKinS solvers, we need to create a Petviashvilli_Asymp structure containing all the fields, working space, diagnostics, etc.  ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"using WavKinS\n\n# Create a waveaction structure containing the basic grid\nMx = 128 # set the number of nodes\nMy = 128 # set the number of nodes\nkxmin = 1e-4 # minimal wave number\nkxmax = 1.e-0 # maximal wave number\nkymin = 1e-4 # minimal wave number\nkymax = 1e-0 # maximal wave number\n\nNk = wave_spectrum_khkz(kxmin,kxmax,Mx,kymin,kymax,My);\n\n# Creating a Petviashvilli_Asymp  structure with default parameters\nRun = Petviashvilli_Asymp(Nk);","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The Petviashvilli_Asymp solver has implemented an option to compute the collisional term as a sink and a source term","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"St_bf k = -gamma_bf k n_bf k + eta_bf k","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The computation of γ and η are performed with the options compute_γk and compute_ηk and accessible as:    ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"# computing collisional integral\nSt_k!(Run;compute_Sk=true, compute_γk=true, compute_ηk=true)\nγ_k = Run.γk\nη_k = Run.ηk    ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"If both, compute_γk=false and compute_ηk=false, then St_k is computed directly.","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"warning: Warning\nThe PetviashvilliAsymp solver is compatible with the time stepping `ABEulerstepandAB2RK2_step`, but still under testing. ","category":"page"},{"location":"physical_systems/Petviashvilli.html#Diagnostics","page":"Petviashvilli","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Spectral and global quantities can be directly computed using the provided routines (see  this tutorial). In addition to the standard diagnostics, the solver computes the total potential enstrophy, zonostrophy, and their respective dissipation. They are stored in","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"    Run.diags.glob_diag[\"Mx\"].out # total potential enstrophy\n    Run.diags.glob_diag[\"dMx\"].out # total potential enstrophy dissipation\n    Run.diags.glob_diag[\"Phi\"].out # total zonostrophy\n    Run.diags.glob_diag[\"dPhi\"].out # total zonostrophy dissipation","category":"page"},{"location":"physical_systems/Petviashvilli.html#Testing-convergence-of-the-collisional-integral","page":"Petviashvilli","title":"Testing convergence of the collisional integral","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"WavKinS provide a simple test of the numerical convergence of the computation of the collisional integral. The testing script is located in /run/tests/physical_systems/tests_Petviashvilli_Asymp.jl. ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Theoretically, the collisional integral should conserve the energy, the potential enstrophy and the zonostrophy, which means that","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"int_k_x0 omega_bf k St_bf k dbf k=0 quad \nint_k_x0 kx St_bf k dbf k=0 \nint_k_x0 frack_x^3k_y^2 St_bf k dbf k=0","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The following numerical test evaluates those integrals and check the convergence to 0.","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"using WavKinS\n\nfunction nk_test(kx) #we define some test function\n        return abs(ky)^3 * exp(-kx - abs(ky)) * kx^1.5 / (1.0 + abs(ky))\nend\n\nfor M ∈ 2 .^ (4:6)\n    Mx = M\n    My = M\n    kxmin = 5e-3\n    kxmax = 5e+3\n    kymin = 5e-3\n    kymax = 5e+3\n\n    Nk = wave_spectrum_khkz(kxmin, kxmax, Mx, kymin, kymax, My)\n    Run = Petviashvilli_Asymp(Nk; interp_scheeme=WavKinS.bilin_interp_khkz)\n\n    kx = Nk.kkh\n    ky = Nk.kkz\n    kk = Nk.kk\n    KKX = kx .* ones(length(ky))' # we get the two-dimensional mesh\n    KKY = ones(length(kx)) .* ky' # we get the two-dimensional mesh\n    @. Nk.nk = nk_test.(KKX, KKY)\n\n    WavKinS.St_k!(Run) # compute the collisional integral\n\n    get_global_diagnostics!(Run)\n    Ω = Run.diags.glob_diag[\"Mx\"].out[end] # Total potential enstrophy\n    Φ= Run.diags.glob_diag[\"Phi\"].out[end] # Total zonostrophy\n    Ene= Run.diags.glob_diag[\"H\"].out[end] # Total energy\n\n    integ = WavKinS.integrate_with_log_bins_khkz()\n    Flux = wave_spectrum_khkz(kxmin, kxmax, Mx, kymin, kymax, My) #a field to test the convergence \n\n    # Check conservation of energy\n    @. Flux.nk = 2 * Run.Sk.nk * WavKinS.ω_Petviashvilli_Asymp(KKX, KKY)\n    Sum_Flux_Ene = integrate(integ, Flux)\n\n     # Check conservation of pontential entrophy\n    @. Flux.nk = 2 * Run.Sk.nk * WavKinS.ρ_Potential_Petviashvilli_Asymp(KKX, KKY)\n    Sum_Flux_Ω = integrate(integ, Flux)\n\n     # Check conservation of zonostrophy\n    @. Flux.nk = 2 * Run.Sk.nk * WavKinS.ρ_zonostrophy_Petviashvilli_Asymp(KKX, KKY)\n    Sum_Flux_Φ = integrate(integ, Flux)\n\n    println(\"Mx = \", Mx, \", My = \", My, \": sum fluxes E, Ω and Φ: \", Sum_Flux_Ene / Ene, \" \", Sum_Flux_Ω / Ω, \" \", Sum_Flux_Φ / Φ)\nend","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The output of this test is ","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Mx = 16, My = 16: sum fluxes E, Ω and Φ: 1.710268715980057 1.8589880090916744 17.54853293874085\nMx = 32, My = 32: sum fluxes E, Ω and Φ: 0.2945159761052512 0.5493565471964945 7.612825119505001\nMx = 64, My = 64: sum fluxes E, Ω and Φ: 0.047152987403215815 0.09584411074860376 1.3042184389571956\nMx = 128, My = 128: sum fluxes E, Ω and Φ: 0.015444134461320853 0.024791030645795964 0.27800229384109115\nMx = 256, My = 256: sum fluxes E, Ω and Φ: 0.004373987907149068 0.007510845318850708 0.08816734805792001\nMx = 512, My = 512: sum fluxes E, Ω and Φ: 0.001182471464404374 0.002026386307332427 0.02317691111735061\nMx = 1024, My = 1024: sum fluxes E, Ω and Φ: 0.0003036763839915813 0.0004973832086118185 0.005512771277465468\nMx = 2048, My = 2048: sum fluxes E, Ω and Φ: 7.58630402627788e-5 0.00012665788264348718 0.0014091889296611471","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The solver conserves the invariant well and errors roughly decreases as M^-2 as displayed in the next figure","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"(Image: )","category":"page"},{"location":"physical_systems/Petviashvilli.html#Running-the-Petviashvilii-solver","page":"Petviashvilli","title":"Running the Petviashvilii solver","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"WavKinS provides a ready to use script to obtain out-of-equilibrium steady states of the WKE. The script is similar to the one presented in the tutorial and can be found in /run/simple/RunSimpleEvolution_Petviashvilli.jl. Running the script will generate the following plot","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"(Image: )","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"The figure on the left is taken at a very early stage of the simulations where a localised forcing is clearly visible. At a later timed, energy cascades and fill the upper part of the spectral space.","category":"page"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"info: Info\nThe previous simulation took less than 30 seconds on a 3 GHz 10-Core Intel Xeon W iMac Pro, using 16 cores. ","category":"page"},{"location":"physical_systems/Petviashvilli.html#List-of-structures-and-methods-for-Petviashvilli-solvers","page":"Petviashvilli","title":"List of structures and methods for Petviashvilli solvers","text":"","category":"section"},{"location":"physical_systems/Petviashvilli.html","page":"Petviashvilli","title":"Petviashvilli","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/Petviashvilli/basics.jl\", \"src/physical_systems/Petviashvilli/structure.jl\", \"src/physical_systems/Petviashvilli/collision_integral.jl\",\"src/physical_systems/Petviashvilli/diagnostics.jl\"]","category":"page"},{"location":"physical_systems/Petviashvilli.html#WavKinS.Petviashvilli","page":"Petviashvilli","title":"WavKinS.Petviashvilli","text":"Petviashvilli\n\nSimulation structure for Petviashvilli wave turbulence It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``.  1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum_khkz #wave action\nSk::wave_spectrum_khkz #collisional integral\nF1::wave_spectrum_khkz #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{Tuple{UnitRange{Int64},UnitRange{Int64}}} #partition for multithreading\n\n# Type of interpolation, integration, and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ninteg_scheeme::Integ_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\ndimension::Int # physical dimension of the system\ndΩ::Float64 # surface of the unit sphere\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Petviashvilli.html#WavKinS.Petviashvilli_Asymp","page":"Petviashvilli","title":"WavKinS.Petviashvilli_Asymp","text":"Petviashvilli_Asymp\n\nSimulation structure for Petviashvilli for 'kx<<ky' wave turbulence. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``.  1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum_khkz #wave action\nSk::wave_spectrum_khkz #collisional integral\nγk::Array{Float64,2} # gamma term of WKE\nηk::Array{Float64,2} # gamma term of WKE\n\nF1::wave_spectrum_khkz #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt1::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt2::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{Tuple{UnitRange{Int64},UnitRange{Int64}}} #partition for multithreading\n\n# Type of interpolation, integration, and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ninteg_scheeme::Integ_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\ndimension::Int # physical dimension of the system\ndΩ::Float64 # surface of the unit sphere\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Petviashvilli.html#WavKinS.compute_spectral!-Tuple{Union{Petviashvilli, Petviashvilli_Asymp}}","page":"Petviashvilli","title":"WavKinS.compute_spectral!","text":"compute_spectral(Run)\n\nCompute and store Petviashvilli_Asymp current spectral quantities\n\nRun: PetviashvilliAsymp or Petviashvilli WavKinS simulation structure containing the wave action ``n{\\bf k}``\n\nThis routine computes and store in Run.diags.sp_outs the waveaction, energy spectra and their corresponding fluxes.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Petviashvilli.html#WavKinS.get_global_diagnostics!-Tuple{Petviashvilli_Asymp}","page":"Petviashvilli","title":"WavKinS.get_global_diagnostics!","text":"get_global_diagnostics!(Run::Petviashvilli_Asymp)\n\nCompute default global diagnostics\n\nRun: PetviashvilliAsymp simulation structure containing the wave action ``n{\\bf k}``\n\nThis routine computes and store in Run.diags.glob_diag the default diagnostics: The current time, the total waveaction, the total energy, total potential enstrophy, zonostrophy and the corresponding dissipations,\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/Petviashvilli.html#WavKinS.store_spectral!-Tuple{Union{Petviashvilli, Petviashvilli_Asymp}}","page":"Petviashvilli","title":"WavKinS.store_spectral!","text":"store_spectral(Run::Union{Petviashvilli_Asymp,Petviashvilli})\n\nCompute and store Petviashvilli_Asymp spectral quantities\n\nRun: PetviashvilliAsymp or Petviashvilli WavKinS simulation structure containing the wave action ``n{\\bf k}``\n\nThis routine computes and store in Run.diags.sp_store  the waveaction, and the energy and waveaction flux spectra.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/collisional_integral_tutorial.html#Computing-a-collisional-integral","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"","category":"section"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"Look at README.md, and install the code first.","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"In this simple tutorial we show how to initialise the WavKinS, to define a couple of basics structures needed to make calculations, set an initial waveaction and finally compute the collisional integral (the right hand side of the WKE).","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"note: Note\nBefore running any of the commands below you need to indicate to Julia the path to the folder where WavKinS has been installed, here denoted as PATH_TO_WAVKINS_FOLDER. In Linux bash, this is set by setting the JULIA_LOAD_PATH environment variableexport JULIA_LOAD_PATH=\"PATH_TO_WAVKINS_FOLDER:$JULIA_LOAD_PATH\" ","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html#Defining-the-basic-structures.","page":"Computing a collisional integral","title":"Defining the basic structures.","text":"","category":"section"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"One of the most basic structures in WavKinS is the wave_spectrum for isotropic systems. The constructor requires to set the number of nodes, and the smallest and the largest wavenumbers. To initialise a wave_spectrum we do the following","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"## Defining the wave_spectrum structure\nusing WavKinS\nM = 1024\nkmin = 1e-3\nkmax = 1e0\nNk = wave_spectrum(kmin, kmax, M)","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"We have now the waveaction Nk.nk initialised with zeros and the logarithmic grid Nk.kk. We are going set the waveaction to the Rayleigh–Jeans distribution","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"n_bf k = frac1omega_bf k","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"This distribution is a trivial solution of the WKE, which means that St_bf k=0 (Nazarenko, Springer, Volume 825 of Lecture Notes in Physics (2011)). Here omega_bf k is the wave dispersion relation that depends on each physical system.","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"For this tutorial, we will use the Acoustic2D solver. For each solver, there is one structure containing all the methods, arrays, and parameters needed for a simulations. We initialise it as follows","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"Run = Acoustic2D(Nk)","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"Here we did not provide any optional parameters. If desired, one can set the time-stepping, interpolation and integration method, physical parameters etc. We can now set our Rayleigh–Jeans distribution using the dispersion relation included in Run","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"kk = Run.Nk.kk # we rename the wavevector mesh for shorter use\nnk = Run.Nk.nk # we rename the waveaction mesh for shorter use\n@. nk = 1.  / Run.ω(kk) # the @. is the julia macro for pointwise operations","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"Finally, we compute the collisional integral","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"St_k!(Run) # compute the collision integral","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"The collisional integral is stored in the wave_spectrum  structure Run.Sk, and therefore, its values are accessible in Run.Sk.nk.","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"To check the error of the collisional integral, we compute the L^2 norm St =sqrtint_0^infty 2pi k St_k^2 dk","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":" @. Run.Sk.nk = 2pi * kk * Run.Sk.nk^2 # we use the same waveaction structure to compute the square\n\nL2norm = sqrt(integrate_with_log_bins(Run.Sk)); # we integrate collisional integral squared using WavKinS integration\nprintln(\"The L2-norm is \",L2norm)","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"which produces the output","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"The L2-norm is 0.0005670508265665057","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"info: Info\nNote that the Rayleigh–Jeans distributions are not integrable functions, however all integrals in WavKinS have sharp cut-off at kmax, giving mathematical sense to these solutions.","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html#Running-this-example","page":"Computing a collisional integral","title":"Running this example","text":"","category":"section"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"To run the above example for increasing values of the number of points M, just copy the following lines to a file (here called computing_collisional_integral_tutorial.jl)","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"using WavKinS\n\n## Defining the wave_spectrum structure\n\nkmin = 1e-3;\nkmax = 1e0;\n\nfor M ∈ 2 .^ (5:12)\n    Nk = wave_spectrum(kmin, kmax, M)\n\n    # Creating the Run Acoustic2D, filling the waveaction and computing the collisional integral\n    Run = Acoustic2D(Nk)\n    kk = Run.Nk.kk # we rename the wavevector mesh for shorter use\n    nk = Run.Nk.nk # we rename the wavefunction mesh for shorter use\n    @. nk = 1.0 / Run.ω(kk) # the @. is the julia macro for pointwise operations\n\n\n    # Compute the collisional integral and print th\n    St_k!(Run) # compute the collision integral\n\n    # Compute the L2-norm of the collisional integral\n    @. Run.Sk.nk = 2pi * kk * Run.Sk.nk^2 # we use the same waveaction structure to compute the square\n    L2norm = sqrt(integrate_with_log_bins(Run.Sk)) # we integrate collisional integral squared using WavKinS integration\n\n    println(\"M =\", M, \" L2-norm = \", L2norm)\n\nend","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"Then to run the file with 4 threads, simply execute from the terminal","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"julia --threads 4 computing_collisional_integral_tutorial.jl","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"which produces","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"M =32 L2-norm = 0.11497899775058602\nM =64 L2-norm = 0.039508648493920724\nM =128 L2-norm = 0.013842127550835866\nM =256 L2-norm = 0.00486925111983586\nM =512 L2-norm = 0.0016955053736738902\nM =1024 L2-norm = 0.0005670508265665057\nM =2048 L2-norm = 0.00016406073037112257\nM =4096 L2-norm = 2.4680754912948397e-5","category":"page"},{"location":"quick_start/collisional_integral_tutorial.html","page":"Computing a collisional integral","title":"Computing a collisional integral","text":"We observe that error decreases as M^-2.","category":"page"},{"location":"quick_start/installation.html#Installing-WavKinS","page":"Installing WavKinS","title":"Installing WavKinS","text":"","category":"section"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"The following steps are necessary to install WavKinS.","category":"page"},{"location":"quick_start/installation.html#Installation-of-Julia","page":"Installing WavKinS","title":"Installation of Julia","text":"","category":"section"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"Download the Julia Programming Language https://julialang.org and follow the instructions for installation.","category":"page"},{"location":"quick_start/installation.html#Installing-WavkinS","page":"Installing WavKinS","title":"Installing WavkinS","text":"","category":"section"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"To install WavKinS.jl open Julia in project mode. From the WavKinS folder type:","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"> julia --project","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"then enter to the package mode by typing ] and do","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"(@v1.10) pkg> instantiate","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"Julia should download and install all the necessary packages.","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"If you use Visual Studio Code for coding, it is useful to install the julia package Revise.jl.","category":"page"},{"location":"quick_start/installation.html#Generating-Documentation","page":"Installing WavKinS","title":"Generating Documentation","text":"","category":"section"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"To generate a local copy fo the documentation, go to  /docs folder and run","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"julia --project make.jl","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"The package Documenter.jl will generate a webpage in the folder /docs/build. After building, open the file /docs/build/index.html","category":"page"},{"location":"quick_start/installation.html#Getting-started-and-running-the-code","page":"Installing WavKinS","title":"Getting started and running the code","text":"","category":"section"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"The next tutorials show with examples the basic use of WavKinS. In all cases, we need to import the module WavKinS. Assuming that Julia knows where WavKinS has been installed, it is imported by doing","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"using WavKinS","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"before any call to WavKinS routines.","category":"page"},{"location":"quick_start/installation.html","page":"Installing WavKinS","title":"Installing WavKinS","text":"note: Note\nBefore lunching Julia, you need to indicate the path to the folder where WavKinS has been installed, here denoted as PATH_TO_WAVKINS_FOLDER. In Linux bash, this is set by setting the JULIA_LOAD_PATH environment variableexport JULIA_LOAD_PATH=\"PATH_TO_WAVKINS_FOLDER:$JULIA_LOAD_PATH\" ","category":"page"},{"location":"physical_systems/NLS.html#NLS3Dsolver","page":"NLS","title":"NLS3Dsolver","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The nonlinear Schrodinger (NLS) equation is one of the most important model in physics. It applications vary from nonlinear optics, water waves to Bose-Einsteing condensates. The equation is also known as the Gross-Pitaevskii equation, a fundamental equation describing superfluids.","category":"page"},{"location":"physical_systems/NLS.html#Description","page":"NLS","title":"Description","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"In the solver, we consider the WKE of the 3D-NLS model dotn_k=St_k that explicitly reads","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"\ndotn_k=4pi int delta(bf k+k_1-k_2-k_3)delta(omega^k1_23)n_kn_1n_2n_3left(frac1n_bf k+frac1n_bf 1-frac1n_bf 2-frac1n_bf 3   right)dbf k_1dbf k_2dbf k_3 ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"where omega^k1_23=omega_k+omega_1-omega_2-omega_3, with omega_k = k^2. Note that in the general case, there are 3times3 -3 -1=5 integrals to be performed for each element of in wavevector space. Solving this equation will then require M^8 operation per time-step, where M is the number of discretization points of the wavevector space in each direction. Such an enormous cost makes the simulation numerically unfeasible. In WavKinS, we assume isotropy and consider the isotropic kinetic equation which drastically reduces the number of computations.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"This wave kinetic equation conserves the total energy H and waveaction N","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"N= int  n_bf kdbf k quad rm and quad H = int omega_bf k n_bf kdbf k","category":"page"},{"location":"physical_systems/NLS.html#Solver","page":"NLS","title":"Solver","text":"","category":"section"},{"location":"physical_systems/NLS.html#The-reduced-isotropic-NLS-wave-kinetic-equation","page":"NLS","title":"The reduced isotropic NLS wave kinetic equation","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"WavKinS solves the isotropic 3DNLS wave kinetic equation (see Zhu et al., Phys. Rev. E 106, 014205 (2022) for a recent derivation and revision of prefactors). After angle average, the collisional integral simplifies considerable and reduces to a bi-dimensional integral. In WavKinS, the collisional integral is computed after performing a change of variable to omega=k^2. The isotropic NLS3D WKE is","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"dotn_k=frac4pi^3k int mathcalS^k1_23delta(omega^k1_23) n_kn_1n_2n_3left(frac1n_k+frac1n_1-frac1n_2-frac1n_3   right)domega_1domega_2domega_3","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"with mathcalS^k1_23=theta_ktheta_1theta_2theta_3 minksqrtomega_1sqrtomega_2sqrtomega_3 and theta_k = 1 if kle k_rm max, and 0 otherwise, with k_rm max the maximum wavenumber. Note that the integration over the resonant manifold is simply given by replacing omega_1=omega_2+omega_3-omega_k.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"This truncated WKE, exactly conserves the truncated invariants Zhu et al., Phys. Rev. E 108, 064207 (2023)","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"N=  4pi int_0^k_rm max n_kk^2dk quad rm and quad H = 4pi int_0^k_rm max omega_k n_kk^2dk","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Note that the numerical cost is now reduced to M^3.","category":"page"},{"location":"physical_systems/NLS.html#Numerical-method","page":"NLS","title":"Numerical method","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Due to the truncation term theta_1theta_2theta_3 the integration domain of the WKE is bounded and reduced to the following domain","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"0leomega_1omega_2omega_3le k_rm max^2","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"which correspond to the coloured area in the figure. (Image: )","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"We use logarithmic grid wave_spectrum to represent the waveaction spectrum n_k. The integrals in the collisional term are also computed wave_spectrum structures supported on (0k_rm max^2, and taking care of the boundaries of the domain that can be out of grid. There are no singular terms to take care of. ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The different options are described in the NLS3D documentation.","category":"page"},{"location":"physical_systems/NLS.html#Using-the-NLS3D-solver","page":"NLS","title":"Using the NLS3D solver","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"As all the other WavKinS solvers, for NLS3D we need to create a NLS3D structure containing all the fields, working space, diagnostics, etc.  ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"using WavKinS\n\n# Create a waveaction structure containing the basic grid\nM = 256 # set the number of nodes\nkmin = .9e-3 # minimal wave number\nkmax = 5e+0 # maximal wave number\nNk = wave_spectrum(kmin, kmax, M)\n\n# Creating a NLS3D run structure with default parameters.\nRun = WavKinS.NLS3D(Nk);","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The NLS3D solver has implemented an option to compute the collisional term as a sink and a source term","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"St_bf k = -gamma_bf k n_bf k + eta_bf k","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The computation of γ and η are performed with the options compute_γk and compute_ηk and accesible as:    ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"# computing collisional integral\nSt_k!(Run;compute_Sk=true, compute_γk=true, compute_ηk=true)\nγ_k = Run.γk\nη_k = Run.ηk    ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"If both, compute_γk=false and compute_ηk=false, then St_k is computed directly.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"warning: Warning\nThe NLS3D solver is compatible with the time stepping AB_Euler_step and AB2_RK2_step, but still under testing. ","category":"page"},{"location":"physical_systems/NLS.html#Diagnostics","page":"NLS","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"In addition to the standard diagnostics, the solver computes the waveaction flux spectrum.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Q_k = -4piint_0^k St_q q^2dq","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Spectral and global quantities can be directly computed using the provided routines (see  this tutorial). It is stored in ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"  Run.diags.sp_outs[\"Qk\"] # for I/0 purposes\n  Run.diags.sp_store[\"Qk\"] # stored over time","category":"page"},{"location":"physical_systems/NLS.html#Testing-convergence-of-the-collisional-integral","page":"NLS","title":"Testing convergence of the collisional integral","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"WavKinS provide a simple test of the numerical convergence of the computation of the collisional integral. The testing script is located in /run/tests/physical_systems/tests_NLS3D.jl. ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Theoretically, the collisional integral should conserve the waveaction and the energy, which means that","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"int_0^k_rm max St_k k^2 dk=0 quad int_0^k_rm max omega_k St_k k^2dk=0","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The following numerical test evaluates those integrals and check the convergence to 0.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"using WavKinS\n\nfunction nk_test(kx)\n    return exp(-abs(kx)^2) * kx^2\nend\n\nprintln(\"---------------------------------------------------------------------\")\nprintln(\"Testing collisional integral\")\nprintln(\"\")\n\nfor M ∈ 2 .^ (4:9)\n    kmin = 1e-2\n    kmax = 1e+1\n\n    Nk = wave_spectrum(kmin, kmax, M)\n    Run = WavKinS.NLS3D(Nk)\n\n    kk = Nk.kk\n    @. Nk.nk = nk_test.(kk)\n\n    WavKinS.St_k!(Run; compute_Sk=true, compute_γk=false, compute_ηk=false)\n\n    Flux = wave_spectrum(kmin, kmax, M)\n    @. Flux.nk = kk^4 * Run.Sk.nk\n    FluxNumH = integrate_with_log_bins(Flux)\n\n    @. Flux.nk = kk^2 * Run.Sk.nk\n    FluxNumN = integrate_with_log_bins(Flux)\n\n    AA = total_waveaction(Run)\n    Ene = energy(Run)\n\n    println(\"M in k= \", M, \", Integral flux num: dN/n=\", FluxNumN / AA, \" dH/H=\", FluxNumH / Ene)\nend\n\nprintln(\"\")\nprintln(\"---------------------------------------------------------------------\")","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The output of this test is ","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"---------------------------------------------------------------------\nTesting collisional integral\n\nM in k= 16, Integral flux num: dN/n=-1.1921326630233626 dH/H=-1.4541383004395845\nM in k= 32, Integral flux num: dN/n=-0.44858827560085296 dH/H=-0.550829241400805\nM in k= 64, Integral flux num: dN/n=-0.13109042503536641 dH/H=-0.169719084207455\nM in k= 128, Integral flux num: dN/n=-0.03668301242101203 dH/H=-0.04868205790683482\nM in k= 256, Integral flux num: dN/n=-0.009695220531387884 dH/H=-0.012918492831232576\nM in k= 512, Integral flux num: dN/n=-0.0026314061815940525 dH/H=-0.003391676130269483\n\n---------------------------------------------------------------------","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The solver conserves well the waveaction and errors on energy conservation roughly decreases as M^-2.","category":"page"},{"location":"physical_systems/NLS.html#Theoretical-predictions","page":"NLS","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"The wave turbulence theory provides analytical prediction for out-of-equilibrium steady states obtained with forcing and dissipation. The theory predict a inverse cascade of waveaction and a direct cascade of energy. The corresponding theoretical prediction are (see Zhu et al., Phys. Rev. Lett. 130, 133001 (2023) :","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"n_k=C_KZ^Q Q_0^13k^-73quad n_k=C_KZ^P P_0^13k^-3ln^-13(kk_f)","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"where Q_0 and P_0 are the waveaction and energy fluxes, and the superscript Q and P denotes the inverse waveaction and direct energy cascades, respectively. Here, k_f denotes the forcing scale appearing due to non-locality of the direct energy cascade. The theory also predicts the values of the dimensionless constants","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"C_KZ^Q =7577times 10^-2  quad C_KZ^P=526times 10^-2 ","category":"page"},{"location":"physical_systems/NLS.html#Running-the-NLS3D-solver","page":"NLS","title":"Running the NLS3D solver","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"WavKinS provides a ready to use script to obtain out-of-equilibrium steady states of the WKE. The script is similar to the one presented in the tutorial and can be found in /run/simple/RunSimpleEvolution_NLS3D.jl. Running the script will generate the following plot exhibiting the steady state inverse waveaction cascade","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"(Image: ) The dashed lines are the theoretical predictions for the inverse waveaction (green) and direct energy (red) cascades, with no adjustable parameters.","category":"page"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"info: Info\nThe previous plot took 290 seconds on a 3 GHz 10-Core Intel Xeon W iMac Pro, using 4 cores. ","category":"page"},{"location":"physical_systems/NLS.html#List-of-structures-and-methods-for-NLS-solvers","page":"NLS","title":"List of structures and methods for NLS solvers","text":"","category":"section"},{"location":"physical_systems/NLS.html","page":"NLS","title":"NLS","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/NLS3D/basics.jl\", \"src/physical_systems/NLS3D/structure.jl\", \"src/physical_systems/NLS3D/collision_integral.jl\",\"src/physical_systems/NLS3D/diagnostics.jl\"]","category":"page"},{"location":"physical_systems/NLS.html#WavKinS.NLS3D","page":"NLS","title":"WavKinS.NLS3D","text":"NLS3D\n\nSimulation structure for MMT wave turbulence. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``.  1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nγk::Vector{Float64} # gamma term of WKE\nηk::Vector{Float64} # eta term of WKE\n\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt1::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt2::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt3::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt4::Vector{wave_spectrum} #Array of working fields for multithreading\nFSt5::Vector{wave_spectrum} #Array of working fields for multithreading\n\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation ,integration, and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ninteg_scheeme::Integ_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\ndimension::Int # physical dimension of the system\ndΩ::Float64 # surface of the unit sphere\n\nFD::force_dissipation # Contains all the terms about force and dissipation\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/NLS.html#WavKinS.NLS3D-Tuple{wave_spectrum}","page":"NLS","title":"WavKinS.NLS3D","text":"NLS3D(Nk::wave_spectrum;interp_scheeme=lin_interp,drive_scheeme=RK2_step)\n\nConstructor of a NLS3D structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheem : lininterp (default), powexpinterp, powGaussinterp,BSinterp\ntime_stepping_scheeme: Euler_step, RK2_step (default), RK4_step, ETD2_step and ETD4_step\n\nThe parameter β=0. is the exponent of non-linear term\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/NLS.html#WavKinS.compute_spectral!-Tuple{NLS3D}","page":"NLS","title":"WavKinS.compute_spectral!","text":"compute_spectral(Run)\n\nCompute and store NLS3D current spectral quantities\n\nRun: NLS3D WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_outs the waveaction, energy spectra and their corresponding fluxes.\n\n\n\n\n\n","category":"method"},{"location":"physical_systems/NLS.html#WavKinS.store_spectral!-Tuple{NLS3D}","page":"NLS","title":"WavKinS.store_spectral!","text":"store_spectral(Run::NLS3D)\n\nCompute and store NLS3D spectral quantities\n\nRun: NLS3D WavKinS simulation structure containing the wave action n_bf k\n\nThis routine computes and store in Run.diags.sp_store  the waveaction, and the energy and waveaction flux spectra.\n\n\n\n\n\n","category":"method"},{"location":"index.html#WavKinS:-Wave-Kinetic-equations-Solver","page":"Home","title":"WavKinS: Wave Kinetic equations Solver","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Wave kinetic equations arrive in many physical systems, such as plasmas, geophysical fluids, elastic plates, turbulent Bose-Einstein condensates, and many others. When the nonlinearity is small, the theory of Weak Wave Turbulence (WWT) provides a close equation describing the evolution of the wave spectrum, roughly describing the wave amplitude or energy at a given scale. WavKinS currently solves kinetic equations of the 3—and 4-wave types, as described below.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"WavKinS is software developed in the Julia language. It aims to provide a simple and efficient general solver of wave kinetic equations. Thanks to the structures and routines already developed in WavKinS, we expect developing a new solver for a specific physical system to be simple.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nWavKinS is a project under development; many routines could still be improved for accuracy or efficiency. All remarks and contributions from the scientific community are welcome! ","category":"page"},{"location":"index.html#License","page":"Home","title":"License","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"WavKinS.jl is an Open Source project distributed with EUPL-1.2 license agreement. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"info: Citing WavKinS and intellectual recognition\nIn addition to the EUPL obligations; the use of this Work for the analysis, creation or modification of data imposes on the Licensee, in each of their publications resulting from the exploitation of these data, the obligation to cite the first articles where this Work was used: V. Labarre, G. Krstulovic and S. Nazarenko arXiv:2407.11469 and Y. Zhu, G. Krstulovic and S. Nazarenko arXiv:2408.15163.","category":"page"},{"location":"index.html#General-description","page":"Home","title":"General description","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This program solves the Wave Kinetic Equation (WKE)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fracmathrmdn_bf kmathrmdt = St_bf k + f_bf k - d_bf k n_bf k","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where n_bf k is the wave-action spectrum, St_bf k is the collisional integral, f_bf k is the forcing, and d_bf k the dissipation coefficient. Their definitions depend on the physical problem. See e.g. Nazarenko, Springer, Volume 825 of Lecture Notes in Physics (2011) for an introduction on the topic. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The WKE can be classified by the number of waves interacting, which results in different degrees of nonlinearity and integrations to be performed. In the current version of the code, we consider two types of systems that can be generically written as follows.","category":"page"},{"location":"index.html#3-waves-canonical-systems","page":"Home","title":"3-waves canonical systems","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In this case the collisional integral reads","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"St_bf k=int (mathcalR^bf k_12-mathcalR^1_2 bf k-mathcalR^2_bf k1)mathrmdbf k_1mathrmdbf k_2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"with mathcalR^bf k_12=V_bf k12^2(n_1n_2-n_1n_bf k-n_bf kn_2)delta(bf k-bf k_1-bf k_2)delta(omega_bf k- omega_1- omega_2), V_bf k12 is the interaction coefficient, and omega_bf k is the wave frequency. Systems with interactions involving more than 3 waves and/or having a noncanonical structure can be implemented as well.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that if wavevectors are in dimension d, then there are 2d - d - 1=d-1 integrals to be performed for each value of a external wavevector bf k. Therefore, if we use M points to discretise each coordinate of the wavevector space, then the numerical cost will be generically of the order of M^2d -1 operations. However, assuming full isotropy or isotropy in a plane can drastically reduce the numerical cost, making calculations possible.","category":"page"},{"location":"index.html#4-waves-canonical-systems","page":"Home","title":"4-waves canonical systems","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In these systems there is one extra integral","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"St_bf k=int T^bf k 1_bf 2 3^2delta(bf k+bf k_1-bf k_2-bf k_3)delta(omega^bf k 1_bf 2 3) n_bf kn_bf 1n_bf 2n_bf 3left( frac1n_bf k + frac1n_bf 1 -frac1n_bf 2 -frac1n_bf 3 right)mathrmdbf k_1mathrmdbf k_2mathrmdbf k_2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"with omega^bf k 1_bf 2 3=omega_bf k+ omega_bf 2- omega_bf 3-omega_bf 4 and T^bf k 1_bf 2 3 the interaction coefficient.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For these systems, there are 3d-d-1=2d-1 integrals to be performed, which implies in general a numerical cost of the order of M^3d-1 operations.","category":"page"},{"location":"index.html#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We mostly use logarithmic grids to span larger range of scales (wavevectors). The code includes standard interpolation and integration schemes adapted to these grids. Standard time evolution schemes (Euler, RK2, RK4, and Splitting methods) with adaptative time steps are also implemented. For most physical systems, we define basic outputs (e.g. wave-action, energy, and associated fluxes), that can be saved during the simulations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Wavkins intends to be a generic and modular solver in which new physical systems should be easily implemented, see section How to create a new solver. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nWavKinS is still under development. Although it has been carefully tested you can use at your own digression. If you find any bug or mathematical inconsistency please report it to make this solver","category":"page"},{"location":"index.html#Physical-systems","page":"Home","title":"Physical systems","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We have developed solvers for several physical systems. These solvers have been written in past and current scientific research projects for scientific purposes.","category":"page"},{"location":"index.html#Currently-available-systems","page":"Home","title":"Currently available systems","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Acoustic2D: Isotropic two-dimensional acoustic wave turbulence.\nAcoustic3D: Isotropic three-dimensional acoustic wave turbulence. \nBogoliubov3D: Isotropic three-dimensional Bogoliubov wave turbulence.\nMMT: Majda-McLaughlin-Tabak model.\nNLS3D: Isotropic three dimensional non-linear Schrödinger equation.\nPetviashvilli_Asymp: Waves systems based on the Petviashvilli equation in the strongly anisotropic limit.\nStratified_Asymp: Three-dimensional internal gravity wave turbulence in the strongly anisotropic (hydrostatic) limit. \nSmoluchowski: Smoluchowski coagulation equation.","category":"page"},{"location":"index.html#Under-development","page":"Home","title":"Under development","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Acoustic2D_kxky: two-dimensional acoustic wave turbulence with anisotropic forcing and dissipation.\nIGW_Asymp : internal and inertial gravity waves in the strongly anisotropic (hydrostatic) limit. \nIGW :  non-hydrostatic internal and inertial gravity waves","category":"page"},{"location":"index.html#Code-structure","page":"Home","title":"Code structure","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The code is decomposed as follows:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"src: Source files of the code. It is divided into several parts:\ngrid: Structures and functions for the grids.\nintegration: Tools used for integrations, mainly for log grids. \ninterpolation: Tools used for interpolations, mainly for log grids.\nmisc: Miscellaneous tools, that are still not classified.\nphysical_systems: Structures and necessary functions for the simulations of wave systems. We use a sub-folder for each systems, which contains: \nbasics.jl: Definitions of the frequency, interaction coefficients, resonant manifold, ...\ncollision_integral.jl: Define the method St_k! for computing the collision integral. St_k! is overloaded, allowing to have the same syntax for all solvers. \nstructure.jl: Structure for the run.\nspecial.jl: Non-standard diagnostics/functions (not for all systems). \nWe give common definitions and structures, used for several wave systems, in [basics_all.jl]. For some wave systems, we packed several variations in the same sub-folders for consistency (e.g. Acoustic contains structures and definitions of isotropic and anisotropic Acoustic wave systems whose dispersion relation is the same, but not the spatial dimension and/or the forcing).\nplot: Standard WavKins plots. They are all made with the Makie.jl package, using the GLMakie.jl backend. #TODO: Move this part elsewhere when separated from the main code.\ntime_stepping: Standard functions for time stepping.\nWavKinS_diagnostics.jl: Definitions of standard diagnostics (total wave-action, total energy, total energy dissipation, energy spectrum, wave-action fluxes, energy fluxes, ...). \nWavKinS_outputs.jl: Inputs/Outputs functions. \nWavKinS_parameters.jl: Structures for simulation parameters (output directory, which outputs, final time, ...).\nWavKinS_partitions_threads.jl: Tools for multithreading. In particular, the functions for getting partitions of nodes among threads.\nWavKinS_structures.jl: Very standard structures used in WavKins simulations (spectra, params containers, ...).\nrun: Run simulations and test the code.\nsimple: Simple simulations for various physical systems.  \ntests: Test the different parts of the code (see the folder src).\npostproc: Example scripts (Julia, Python, and Matlab) that show how we can analyze outputs of some simulations.\nmaterials: Useful references and notebooks that explain the theory and some technical parts of the code.\ndocs: Documentation.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Main:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Giorgio Krstulovic (krstulovic@oca.eu) \nVincent Labarre (vincent.labarre@polytechnique.edu) ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other developers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Ying Zhu\nGuillaume Costa","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Scientific collaborators:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Sergey Nazarenko\nJuan Ignacio Polanco","category":"page"},{"location":"quick_start/running_tutorial.html#A-simple-tutorial-to-start","page":"Running an example","title":"A simple tutorial to start","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"In this section, we explain how WavKinS works with a concrete example. To this end, we will use the solver for 2D acoustic waves. Here we explain how to launch a simple simulation to test the direct energy cascade prediction, characterized by constant energy flux to small scales and the steady energy spectrum","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"    e_k = 2pi k omega_k n_bf k = frac4^32 sqrta c3 pi  k^-1    ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"To this end, we use the script run/simple/RunSimpleEvolution_Acoustic.jl. For more informations about the solver, you can look at this section.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"info: Info\nThe solver is defined in src/physical_systems/Acoustic folder:The basics.jl file contains the dispersion relation ω_Acoustic and squared interaction coefficient appearing in the collision integral S_2DAcoustic. We also usually need methods to parameterize the resonant manifold, etc.\nThe structure.jl file contains the structure containing all necessary variables and methods for a Acoustic2D simulation (grid, waveaction spectrum, collision integral, time, etc).\nThe collision_integral.jl file contains the function [function St_k!(Run::Acoustic2D)] which compute the collision integral St_bf k. For all solvers, the collision integral is [function St_k!(Run::StructureType)] where StructureType is the structure of the simulation. ","category":"page"},{"location":"quick_start/running_tutorial.html#Run-simple-evolution","page":"Running an example","title":"Run simple evolution","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"In this section, we explain the different part of the run/simple/RunSimpleEvolution_Acoustic.jl script. ","category":"page"},{"location":"quick_start/running_tutorial.html#Includes","page":"Running an example","title":"Includes","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The first part of the script ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"push!(LOAD_PATH, \"../\")\nusing WavKinS\nusing GLMakie;\nGLMakie.activate!();\nusing TimerOutputs","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"is to import modules. Here, we need WavKinS, GLMakie for plots, and TimerOutputs to test performances. ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"note: Note\nThe module GLMakie does not work on some systems (clusters).","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The lines","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"if Threads.nthreads() == 1\n    @warn \"Set the number of threads by doing export JULIA_NUM_THREADS \"\nend","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"warns you in case you use only 1 thread.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"note: Note\nWavKinS is parallelized so you can use several threads on most modern computers, speeding up simulations. For example, to run the script with 8 threads, go to run/simple folder and run:julia --project --threads 8 RunSimpleEvolution_Acoustic.jl","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"const to = TimerOutput()","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"defines the timer for outputs to check the code's performance.","category":"page"},{"location":"quick_start/running_tutorial.html#The-time-loop","page":"Running an example","title":"The time loop","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"To do the time advancement and manage the outputs and plots, we define the following function ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"function run_simple_evol(Run, Param, Tfinal)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"that take the Run, the simulation parameters, and the final time of the simulation as arguments. In the following lines","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"    step_scheeme = Run.time_stepping\n    init_temporal_scheeme!(step_scheeme, Run, Param.dt)\n    tini = Run.t\n    tplotEvol = tini\n    tglobalEvol = tini\n    tsptoreEvol = tini\n    tspwriteEvol = tini\n    t = tini","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"we define a shortcut for the time-stepping method and initialize time-stepping and time variables.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The constants of the theoretical prediction for the energy spectrum are defined here","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"    V0GP = 3 * sqrt(Run.c / 2.0) / 4.0\n\n    if Run.name == \"Acoustic2D\"\n        Cd = 4^(1 / 4) * sqrt(Run.c) / (pi * V0GP)\n        Prefactor = Cd * sqrt(Run.a * Run.c)\n        xP = 1\n        iP = findfirst(x -> x >= 5e-2, Run.Nk.kk)\n    elseif Run.name == \"Acoustic3D\"\n        Prefactor = sqrt(3 * Run.c / (32 * V0GP^2 * π * (π + 4 * log(2) - 1.0)))\n        xP = 3 / 2\n        iP = findfirst(x -> x >= 5e-2, Run.Nk.kk)\n    else\n        Prefactor = 1.0\n        xP = 0.0\n    end","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Note that we also have implemented the 3D acoustic wave case. These constants are used to plot the theoretical prediction.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We start the time loop and stop it if we detect NaNs in the spectrum:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"    @time while t < tini + Tfinal\n        if any(isnan.(Run.Nk.nk))\n            @warn \"We got NaNs. Stop the temporal loop\"\n            break\n        end","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The following lines advance the simulation by one time step.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"        @timeit to \"Advance\" advance!(step_scheeme, Run, Param.dt)\n        t = Run.t","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"info: Info\nThe macro @timeit is used to measure computational time of the advance! method.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The remaining of the function is for writing and storing outputs, and plotting:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"        @timeit to \"Global quantities\" if t >= tglobalEvol\n            get_global_diagnostics!(Run)\n            if Param.write_global\n                output_global(Run, Param.outputDir)\n            end\n            Energy = Run.diags.glob_diag[\"H\"].out[end]\n            WaveAction = Run.diags.glob_diag[\"N\"].out[end]\n            println(\"t =\", Run.t, \"   H(t) =\", Energy, \"     N(t) = \", WaveAction)\n            tglobalEvol += Param.tglobal\n        end\n\n        @timeit to \"Storing spectral quantities\" if t >= tsptoreEvol\n            store_spectral!(Run)\n            tsptoreEvol += Param.tspstore\n        end\n\n        @timeit to \"Writing spectral quantities\" if t >= tspwriteEvol\n            if Param.write_spectral\n                compute_spectral!(Run)\n                output_spectra(Run, Param.outputDir)\n            end\n            tspwriteEvol += Param.tspwrite\n        end\n\n        @timeit to \"Plotting\" if t >= tplotEvol\n            P0 = Run.diags.sp_outs[\"Pk\"].sp[iP]\n            plot_energy!(Run; fig=figE, ax=axE)\n            plot_theo!(axE, kk, Prefactor * sqrt(abs(P0)) * kk .^ (-xP))\n            plot_energy_flux!(Run; fig=figP, ax=axP)\n            sleep(0.0001)\n            tplotEvol += Param.tplot\n        end\n\n    end\nend","category":"page"},{"location":"quick_start/running_tutorial.html#Physical-system,-numerical-scheemes,-and-simulation-parameters","page":"Running an example","title":"Physical system, numerical scheemes, and simulation parameters","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We first define the wave action structure as follows","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"M = 1024\nkmin = 1e-3\nkmax = 1e0\nNk = wave_spectrum(kmin, kmax, M)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"where M is the resolution and kmin and kmax are the minimal and maximal wave vectors. Then we construct the run structure:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Run = Acoustic2D(Nk; a=1.0, interp_scheeme=WavKinS.lin_interp, time_stepping_scheeme=WavKinS.RK2_step)\nkk = Nk.kk\nλ = Nk.λ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Here, we have fixed the disperion length a=1.0, the interpolation method lin_interp and the time stepping metho RK2_step. We also make shortcuts for the wave vector grid kk and the logarithmic increment λ.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We define parameters of the forcing and dissipation, namely the dissipation wavevector kd, the power of the Laplacian operator used for dissipation lapPower, the middle wave vector of the forcing region kf, and the forcing width Δkf.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"kd = 0.25 * kmax\nlapPower = 4\nkf = 2 * kmin\nΔkf = (log(kmax) - log(kmin)) / 25","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We then define a localized forcing with log normal shape, and the dissipation coefficient","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"    f_k propto exp left - frac12 left( 25 fraclog k - log k_rm flog k_rm max - log k_rm min right)^2 right quad d_k = left( frackk_rm d right)^8","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"with the following lines","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"@. Run.Nk.nk = exp(-0.5 * ((log(kk) - log(kf)) / Δkf)^2);\nEE = energy(Run)\n@. Run.FD.f = Run.Nk.nk / EE\n@. Run.FD.D = (kk / kd)^(2 * lapPower)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Note that the forcing is normalized such that the energy injection rate, computed numerically, is equal to one. The final time and the time step are","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Tfinal = 10.0; # Final time of the simulation\ndt = 0.0025 # time step of the simulation","category":"page"},{"location":"quick_start/running_tutorial.html#Outputs","page":"Running an example","title":"Outputs","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We use the boolean","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"isrestart = false # set this to true if simulations uses a restart","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"to start a new simulation, or to restart from the end state of an old simulation.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"You can define the parameters for storing different outputs and the frequency for plots.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"tplot = 0.1; # Plot every tplot times\ntglobal = 0.1; # Compute, store and write global quantities every tglobal times \ntspstore = 20000 # Compute and store spectral quantities every tspstore times\ntspwrite = 0.1 # write spectra every tspwrite\n\noutputDir = \"./\" #output directory\nwrite_global = true #write global\nwrite_nk = true #write wave action\nwrite_Ek = true #write energy spectrum\nwrite_Pk = true #write energy flux   ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We create a simulations parameters container as follows","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"write_spectral = write_nk || write_Ek || write_Pk\nParam = simulation_parameters(dt, tplot, tglobal, tspstore, tspwrite,\n    outputDir, write_global, write_spectral)\n\nRun.diags.sp_outs[\"nk\"].write_sp = write_nk\nRun.diags.sp_outs[\"Ek\"].write_sp = write_Ek\nRun.diags.sp_outs[\"Pk\"].write_sp = write_Pk ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"If isrestart=false, initialize the outputs. Otherwise, we load the spectrum in the simulation file to restart:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"if ~isrestart\n    get_global_diagnostics!(Run)\n    init_IO(Run, Param.outputDir)\n    if Param.write_global\n        output_global(Run, Param.outputDir)\n    end\n    if Param.write_spectral\n        compute_spectral!(Run)\n        output_spectra(Run, Param.outputDir)\n    end\nelse\n    load_spectrum(Run, Param.outputDir)\n    get_global_diagnostics!(Run)\n    compute_spectral!(Run)\nend","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Before running the simulation, we compute and print initial wave action and energy:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"println(\"Run in resolultion M=\", M, \" with λ=\", Run.Nk.λ)\nprintln(\"Total wave action =\", Run.diags.glob_diag[\"N\"].out[end])\nprintln(\"Total energy =\", Run.diags.glob_diag[\"H\"].out[end])","category":"page"},{"location":"quick_start/running_tutorial.html#Simple-plots-and-start-the-simulation","page":"Running an example","title":"Simple plots and start the simulation","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"You can plot the energy spectrum or the energy flux by adapting this part of the script:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"figE, axE = plot_energy!(Run; ylims=(1e-1, 1e+3))\nfigP, axP = plot_energy_flux!(Run, ylims=(-0.5, 1.5))\ndisplay(figP) # figE (figP) if you want to plot energy spectrum (energy flux)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We run the simulation by calling the time loop function as follows","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"run_simple_evol(Run, Param, 0.0) # Good to run first to measure time properly\nreset_timer!(to)\n\nrun_simple_evol(Run, Param, Tfinal)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"You can save energy spectrum and energy flux plots at the end of simulation with","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"save(\"tutorial_energy.png\", figE)\nsave(\"tutorial_flux.png\", figP)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"The outputs are saved in WKE_Acoustic2D_data.nc. ","category":"page"},{"location":"quick_start/running_tutorial.html#Analysis","page":"Running an example","title":"Analysis","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"Running the script should display the temporal evolution of the energy spectrum or the energy flux. At the end of the simulation the energy flux look like this ","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"(Image: )","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We see a plateau in the inertial range kf  k  kd, whose height is equal to the energy injection rate, which is one.  It corresponds to a constant energy flux to small scale. In the dissipative range k  kd, the energy flux tends to zero, meaning that the collision integral conserves the energy.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We show the energy spectrum in the following figure","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"(Image: )","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"It allows to compare it to the theoretical prediction e(k) = frac4^32 sqrtac 3pi k^-1, shown with a dashed line. We see a good agreement in the inertial range.","category":"page"},{"location":"quick_start/running_tutorial.html#Performances","page":"Running an example","title":"Performances","text":"","category":"section"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"At the end of the simulation, you can look at the perfomances of the code by using","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"println(to)","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"which displays a detailed statistical analysis of time and memory usages of the different functions:","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":" 34.288965 seconds (913.48 k allocations: 105.154 MiB, 0.04% gc time)\n────────────────────────────────────────────────────────────────────────────────────────\n                                               Time                    Allocations      \n                                      ───────────────────────   ────────────────────────\n          Tot / % measured:                34.3s /  99.9%            105MiB /  83.6%    \n\nSection                       ncalls     time    %tot     avg     alloc    %tot      avg\n────────────────────────────────────────────────────────────────────────────────────────\nAdvance                        4.00k    33.3s   97.3%  8.33ms   48.1MiB   54.7%  12.3KiB\nPlotting                       4.00k    378ms    1.1%  94.6μs   32.6MiB   37.1%  8.35KiB\nGlobal quantities              4.00k    297ms    0.9%  74.3μs   1.78MiB    2.0%     466B\nWriting spectral quantities    4.00k    261ms    0.8%  65.3μs   5.42MiB    6.2%  1.39KiB\nStoring spectral quantities    4.00k   2.16ms    0.0%   541ns   24.5KiB    0.0%    6.27B\n────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"We see that the simulation was completed in simeq 343 s and has used simeq 105 MiB of memory.","category":"page"},{"location":"quick_start/running_tutorial.html","page":"Running an example","title":"Running an example","text":"note: Note\nTimerOutputs is very useful to find perfomances issues in julia's codes.","category":"page"},{"location":"physical_systems/Bogoliubov.html#Bogoliubov3Dsolver","page":"Bogoliubov","title":"Bogoliubov3Dsolver","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html#Description","page":"Bogoliubov","title":"Description","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"In this case, the collisional terms simpilfies to","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"St_k= frac4 pick^2 int left(mathcalN^k_12-mathcalN^1_2k-mathcalN^2_k1right)k_1 k_2 mathrmdk_1mathrmdk_2","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"With mathcalN^k_12=V_12^k^2(n_1n_2-n_1n_k-n_kn_2)delta(omega_k-omega_1-omega_2), ","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"V_12^k = V_0sqrtkk_1k_2 left frac12sqrteta_k eta_1 eta_2 + fracsqrteta_k eta_1 eta_26 k k_1 k_2 left( frack^3eta_k - frack^3eta_1 - frack^3eta_2 right) right","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"and eta_k = sqrt1+(kxi)^22. c is the speed of sound and xi the healing length.","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"The dispersion relation is omega_k=cksqrt1+(kxi)^22. See Zhu et al., arXiv, 2408.15163 (2024). Note that the limit xi rightarrow 0 corresponds to Acoustic3Dsolver.","category":"page"},{"location":"physical_systems/Bogoliubov.html#Solver","page":"Bogoliubov","title":"Solver","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"We use the resonance condition omega_k - omega_1 - omega_2 = 0 and the symmetry k_1 leftrightarrow k_2 to reduce the collision integral to","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"St_k = I_k - 2 J_k","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"where","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"I_k = frac4 pick^2 intlimits_0^k  fracV_k12^2g(k_2) (n_1n_2-n_1n_k-n_kn_2)  k_1 k_2  mathrmdk_1","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"and","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"J_k = frac4 pick^2 intlimits_k^k_rm max  fracV_k12^2g(k_2)(n_kn_2-n_kn_1-n_1n_2)  k_1 k_2  mathrmdk_1","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"with the integrands being computed using k_2 solution to omega_2 = pm (omega_k - omega_1), i.e.","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"k_2 = k_2(k k_1) = frac1xi left sqrt1 + frac2 xi^2c^2 (omega_k - omega_1)^2 - 1 right^12","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"and k_rm max the maximal wave vector modulus. We introduced the factor ","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"g(k_2) = left fracpartial (omega_k - omega_1 - omega_2)partial k_2 right = left fracpartial (omega_1 - omega_k - omega_2)partial k_2 right = c\nfrac1 + xi^2 k^2sqrt1 + xi^2 k^22","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"comming from the integration of  delta(omega_k - omega_2 - omega_2).","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"We use logarithmic grid wave_spectrum. The different options are described in the Bogoliubov3D documentation.","category":"page"},{"location":"physical_systems/Bogoliubov.html#Diagnostics","page":"Bogoliubov","title":"Diagnostics","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"The standard diagnostics should work for this system.","category":"page"},{"location":"physical_systems/Bogoliubov.html#Theoretical-predictions","page":"Bogoliubov","title":"Theoretical predictions","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"For large scale (kxi ll 1), the system describes acoustic waves and the Kolmogorov-Zakharov energy spectrum is the Zakharov-Sagdeev (ZS) spectrum.","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"E(k) = 4pi k^2 omega_k n_bf k = fracsqrtc P k^-32sqrt3pi(pi + 4 ln 2  1)","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"with P the energy injection rate.","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"For small scale (kxi gg 1), the Kolmogorov-Zakharov energy spectrum is ","category":"page"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"E(k) = 4pi k^2 omega_k n_bf k = frac 2^34 sqrtc P xi^5 ksqrtpi(pi  4 ln 2)","category":"page"},{"location":"physical_systems/Bogoliubov.html#List-of-structures-and-methods-for-Bogoliubov-solvers","page":"Bogoliubov","title":"List of structures and methods for Bogoliubov solvers","text":"","category":"section"},{"location":"physical_systems/Bogoliubov.html","page":"Bogoliubov","title":"Bogoliubov","text":"Modules = [WavKinS]\nOrder   = [:type, :function]\nPages   = [\"src/physical_systems/Bogoliubov/basics.jl\", \"src/physical_systems/Bogoliubov/structure.jl\", \"src/physical_systems/Bogoliubov/collision_integral.jl\"]","category":"page"},{"location":"physical_systems/Bogoliubov.html#WavKinS.Bogoliubov3D","page":"Bogoliubov","title":"WavKinS.Bogoliubov3D","text":"Bogoliubov3D\n\nSimulation structure for Bogoliubov 3D wave turbulence. It contains\n\nname::String #name of the simulation type\nNk_arguments::Int # Number of arguments of ``n_k``. 1: (fully symetric) , 2: (cylindrical average in 3D or mirror symmetric in 2D), 3: Only mirror symmetric in 3D\nω # Dispersion relation. This is a function of ``k``. It takes `Nk_argument` arguments\n\nNk::wave_spectrum #wave action\nSk::wave_spectrum #collisional integral\nF1::wave_spectrum #working field\nFSt::Vector{wave_spectrum} #Array of working fields for multithreading\npartition::Vector{UnitRange{Int64}} #partition for multithreading\n\n# Type of interpolation and time stepping scheemes\ninterp_scheeme::Interp_Scheeme\ntime_stepping::Time_Stepping\n\n# Outputs and diagnostics\ndiags::diagnostic_container\n\nt::Float64 #current time\nξ::Float64 # healing length\nc::Float64 # speed of sound\ndimension::Int # physical dimension of the system (or of the isotropic sector)\ndΩ::Float64 # surface of the unit sphere (or of the isotropic sector)\n\nFD::force_dissipation # Contains all the terms about force and dissipation.\n\n\n\n\n\n","category":"type"},{"location":"physical_systems/Bogoliubov.html#WavKinS.Bogoliubov3D-Tuple{wave_spectrum}","page":"Bogoliubov","title":"WavKinS.Bogoliubov3D","text":"Bogoliubov3D(Nk::wave_spectrum; ξ=1.0, c=1.0,, interp_scheeme=lin_interp, time_stepping_scheeme=RK2_step\n\nConstructor of a Bogoliubov3D structure. Optionally we set interpolation and time-stepping scheemes:\n\ninterp_scheeme: lin_interp (default), powexp_interp, powGauss_interp, BS_interp\ntime_stepping_scheeme: Euler_step, RK2_step (default), ETD2_step\n\nThe optional parameter c=1.0, ξ=1.0 are the speed of sound and the healing lenght\n\n\n\n\n\n","category":"method"}]
}
